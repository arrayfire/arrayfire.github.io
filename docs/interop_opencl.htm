<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Interoperability with OpenCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="afw.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/>
  </td>
	 <td id="gsearch">
   <div><script>
	    (function() {
        var cx = '004356362924927882526:zup3ehe-7bs';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
	    var s = document.getElementsByTagName('script')[0];
	    s.parentNode.insertBefore(gcse, s);
	  })();
  </script>
  <gcse:search></gcse:search>
</div>
	 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.htm"><span>Tutorials</span></a></li>
      <li><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('interop_opencl.htm','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Interoperability with OpenCL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>As extensive as ArrayFire is, there are a few cases where you are still working with custom <a class="el" href="interop_cuda.htm">CUDA</a> or <a class="el" href="interop_opencl.htm">OpenCL</a> kernels. For example, you may want to integrate ArrayFire into an existing code base for productivity or you may want to keep it around the old implementation for testing purposes. Arrayfire provides a number of functions that allow it to work alongside native OpenCL commands. In this tutorial we are going to talk about how to use native OpenCL memory operations and custom OpenCL kernels alongside ArrayFire in a seamless fashion.</p>
<h1>OpenCL Kernels with Arrayfire arrays</h1>
<p>First, we will see how custom OpenCL kernels can be integrated into Arrayfire code. Let's consider the following code and then break it down bit by bit.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> x = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(num);</div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> y = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(num);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> *d_x = x.<a class="code" href="group__device__func__device.htm#ga93c855ccd22d37cf90d32aef5ac75030">device</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">    <span class="keywordtype">float</span> *d_y = y.<a class="code" href="group__device__func__device.htm#ga93c855ccd22d37cf90d32aef5ac75030">device</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Launch kernel to do the following operations</span></div>
<div class="line">    <span class="comment">// y = sin(x)^2 + cos(x)^2</span></div>
<div class="line">    launch_simple_kernel(d_x, d_y, num);</div>
<div class="line"></div>
<div class="line">    x.<a class="code" href="classaf_1_1array.htm#ab896fcbef7ce95ee1dc6a8c633240ee6">unlock</a>();</div>
<div class="line">    y.<a class="code" href="classaf_1_1array.htm#ab896fcbef7ce95ee1dc6a8c633240ee6">unlock</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for errors, should be 0,</span></div>
<div class="line">    <span class="comment">// since sin(x)^2 + cos(x)^2 == 1</span></div>
<div class="line">    <span class="keywordtype">float</span> err = af::sum&lt;float&gt;(<a class="code" href="group__arith__func__abs.htm#ga23aa8c28a5ffa9368cc92abb143f5eaa">af::abs</a>(y-1));</div>
<div class="line">    printf(<span class="stringliteral">&quot;Error: %f\n&quot;</span>, err);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Breakdown</h2>
<p>Most kernels require an input. In this case, we created a random uniform array <code>x</code> We also go ahead and prepare the output array. The necessary memory required is allocated in array <code>y</code> before the kernel launch.</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> x = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(num);</div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> y = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(num);</div>
</div><!-- fragment --><p>In this example, the output is the same size as in the input. Note that the actual output data type is not specified. For such cases, ArrayFire assumes the data type is single precision floating point (<a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">af::f32</a>). If necessary, the data type can be specified at the end of the array(..) constructor. Once you have the input and output arrays, you will need to extract the device pointers / objects using <a class="el" href="group__device__func__device.htm#ga93c855ccd22d37cf90d32aef5ac75030">af::array::device()</a> method in the following manner.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> *d_x = x.<a class="code" href="group__device__func__device.htm#ga93c855ccd22d37cf90d32aef5ac75030">device</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line"><span class="keywordtype">float</span> *d_y = y.<a class="code" href="group__device__func__device.htm#ga93c855ccd22d37cf90d32aef5ac75030">device</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
</div><!-- fragment --><p>Accesing the device pointer in this manner internally sets a flag prohibiting the arrayfire object from further managing the memory. Ownership will need to be returned to the <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a> object once we are finished using it.</p>
<div class="fragment"><div class="line"><span class="comment">// Launch kernel to do the following operations</span></div>
<div class="line"><span class="comment">// y = sin(x)^2 + cos(x)^2</span></div>
<div class="line">launch_simple_kernel(d_x, d_y, num);</div>
</div><!-- fragment --><p>The function <code>launch_simple_kernel</code> handles the launching of your custom kernel. We will have a look at the specific functions Arrayfire provides to interface with OpenCL later in the post.</p>
<p>Once you have finished your computations, you have to tell ArrayFire to take control of the memory objects.</p>
<div class="fragment"><div class="line">x.<a class="code" href="classaf_1_1array.htm#ab896fcbef7ce95ee1dc6a8c633240ee6">unlock</a>();</div>
<div class="line">y.<a class="code" href="classaf_1_1array.htm#ab896fcbef7ce95ee1dc6a8c633240ee6">unlock</a>();</div>
</div><!-- fragment --><p>This is a very crucial step as ArrayFire believes the user is still in control of the pointer. This means that ArrayFire will not perform garbage collection on these objects resulting in memory leaks. You can now proceed with the rest of the program. In our particular example, we are just performing an error check and exiting.</p>
<div class="fragment"><div class="line"><span class="comment">// check for errors, should be 0,</span></div>
<div class="line"><span class="comment">// since sin(x)^2 + cos(x)^2 == 1</span></div>
<div class="line"><span class="keywordtype">float</span> err = <a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">af::sum</a>(<a class="code" href="group__arith__func__abs.htm#ga23aa8c28a5ffa9368cc92abb143f5eaa">af::abs</a>(y-1));</div>
<div class="line">printf(<span class="stringliteral">&quot;Error: %f\n&quot;</span>, err);</div>
</div><!-- fragment --><h2>Launching an OpenCL kernel</h2>
<p>If you are integrating an OpenCL kernel into your ArrayFire code base you will need several additional steps to access Arrayfire's internal OpenCL context. Once you have access to the same context ArrayFire is using, the rest of the process is exactly the same as launching a stand alone OpenCL context.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <span class="keyword">inline</span> launch_simple_kernel(<span class="keywordtype">float</span> *d_y,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">float</span> *d_x,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">int</span> num)</div>
<div class="line">{</div>
<div class="line">    std::string simple_kernel_str = CONST_KERNEL_STRING;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get OpenCL context from memory buffer and create a Queue</span></div>
<div class="line">    cl::Context context(<a class="code" href="group__opencl__mat.htm#ga1984398db67a52977435e653bb842da7">afcl::getContext</a>(<span class="keyword">true</span>));</div>
<div class="line">    cl::CommandQueue queue(<a class="code" href="namespaceafcl.htm#a4bdd87f7ee76ba2ac18a7e1719508d5d">afcl::getQueue</a>(<span class="keyword">true</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Build program and get the required kernel</span></div>
<div class="line">    cl::Program prog = cl::Program(context, simple_kernel_str, <span class="keyword">true</span>);</div>
<div class="line">    cl::Kernel  kern = cl::Kernel(prog, <span class="stringliteral">&quot;simple_kernel&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//set global work dimensions</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> cl::NDRange global(num);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//prepare argumenst</span></div>
<div class="line">    kern.setArg(0, d_y);</div>
<div class="line">    kern.setArg(1, d_x);</div>
<div class="line">    kern.setArg(2, num);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//run kernel</span></div>
<div class="line">    queue.enqueueNDRangeKernel(kern, cl::NullRange, global);</div>
<div class="line">    queue.finish();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>First of all, to access to OpenCL and the interoperability functions we need to include the appropriate headers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencl_8h.htm">af/opencl.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CL/cl.hpp&gt;</span></div>
</div><!-- fragment --><p>The <a class="el" href="opencl_8h.htm">opencl.h</a> header includes a number of functions for getting and setting the context, queue, and device ids used internally in Arrayfire. There are also a number of methods to construct an <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a> from an OpenCL <code>cl_mem</code> buffer object. There are both C and C++ versions of these functions, and the C++ versions are wrapped inside the <a class="el" href="namespaceafcl.htm">afcl</a> namespace. See full datails of these functions in the <a class="el" href="group__opencl__mat.htm">af/opencl.h documentation</a>.</p>
<div class="fragment"><div class="line">cl::Context context(<a class="code" href="group__opencl__mat.htm#ga1984398db67a52977435e653bb842da7">afcl::getContext</a>(<span class="keyword">true</span>));</div>
<div class="line">cl::CommandQueue queue(<a class="code" href="namespaceafcl.htm#a4bdd87f7ee76ba2ac18a7e1719508d5d">afcl::getQueue</a>(<span class="keyword">true</span>));</div>
</div><!-- fragment --><p>We start to use these functions by getting Arrayfire's context and queue. For the C++ api, a <code>true</code> flag must be passed for the retain parameter which calls the <code>clRetainQueue()</code> and <code>clRetainContext()</code> functions before returning. This allows us to use Arrayfire's internal OpenCL structures inside of the cl::Context and cl::CommandQueue objects from the C++ api. Once we have them, we can proceed to set up and enqueue the kernel like we would in any other OpenCL program. The kernel we are using is actually simple and can be seen below.</p>
<div class="fragment"><div class="line">std::string CONST_KERNEL_STRING = R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">__kernel</span></div>
<div class="line"><span class="stringliteral">void simple_kernel(__global float *d_y,</span></div>
<div class="line"><span class="stringliteral">                   __global const float *d_x,</span></div>
<div class="line"><span class="stringliteral">                   const int num)</span></div>
<div class="line"><span class="stringliteral">{</span></div>
<div class="line"><span class="stringliteral">    const int id = get_global_id(0);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    if (id &lt; num) {</span></div>
<div class="line"><span class="stringliteral">        float x = d_x[id];</span></div>
<div class="line"><span class="stringliteral">        float sin_x = sin(x);</span></div>
<div class="line"><span class="stringliteral">        float cos_x = cos(x);</span></div>
<div class="line"><span class="stringliteral">        d_y[id] = (sin_x * sin_x) + (cos_x * cos_x);</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral">)&quot;;</span></div>
</div><!-- fragment --><h1>Reversing the workflow: Arrayfire arrays from OpenCL Memory</h1>
<p>Unfortunately, Arrayfire's interoperability functions don't yet allow us to work with external OpenCL contexts. This is currently an open issue and can be tracked here: <a href="https://github.com/arrayfire/arrayfire/issues/1002">https://github.com/arrayfire/arrayfire/issues/1002</a>.</p>
<p>Once the issue is addressed, it will be possible to take the reverse route and start with completely custom OpenCL code, then transfer our results into <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a> objects. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5076919-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
