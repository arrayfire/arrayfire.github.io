<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: Interoperability with OpenCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/></td>
   <td id="gsearch">
       <div><script>
             (function() {
                 var cx = '004356362924927882526:zup3ehe-7bs';
                 var gcse = document.createElement('script');
                 gcse.type = 'text/javascript';
                 gcse.async = true;
                 gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//www.google.com/cse/cse.js?cx=' + cx;
                 var s = document.getElementsByTagName('script')[0];
                 s.parentNode.insertBefore(gcse, s);
             })();
       </script>
       <gcse:search></gcse:search>
       <div>
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('interop_opencl.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interoperability with OpenCL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Although ArrayFire is quite extensive, there remain many cases in which you may want to write custom kernels in OpenCL or <a class="el" href="interop_cuda.htm">CUDA</a>. For example, you may wish to add ArrayFire to an existing code base to increase your productivity, or you may need to supplement ArrayFire's functionality with your own custom implementation of specific algorithms.</p>
<p>ArrayFire manages its own context, queue, memory, and creates custom IDs for devices. As such, most of the interoperability functions focus on reducing potential synchronization conflicts between ArrayFire and OpenCL.</p>
<h1>Basics</h1>
<p>It is fairly straightforward to interface ArrayFire with your own custom OpenCL code. ArrayFire provides several functions to ease this process including:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function </th><th class="markdownTableHeadNone">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array(...)</a> </td><td class="markdownTableBodyNone">Construct an ArrayFire array from cl_mem references or cl::Buffer objects  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236" title="Get the device pointer from the array and lock the buffer in memory manager.">af::array.device()</a> </td><td class="markdownTableBodyNone">Obtain a pointer to the cl_mem reference (implies <code>lock()</code>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm#a0af0c6e3920cd67025211889c98807db" title="Locks the device buffer in the memory manager.">af::array.lock()</a> </td><td class="markdownTableBodyNone">Removes ArrayFire's control of a cl_mem buffer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680" title="Unlocks the device buffer in the memory manager.">af::array.unlock()</a> </td><td class="markdownTableBodyNone">Restores ArrayFire's control over a cl_mem buffer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga9c5a70a03d0d0bb31b4e7e5a0598752a" title="Get a vendor enumeration for the current platform.">afcl::getPlatform()</a> </td><td class="markdownTableBodyNone">Get ArrayFire's current cl_platform  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__device__func__get.htm#ga4dfe3f90475b735384f8b28cf2b19a11" title="Gets the current device ID.">af::getDevice()</a> </td><td class="markdownTableBodyNone">Get the current ArrayFire Device ID  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#gae40668cc7d19273f449a1628ac438182" title="Get the device ID for ArrayFire&#39;s current active device.">afcl::getDeviceId()</a> </td><td class="markdownTableBodyNone">Get ArrayFire's current cl_device_id  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__device__func__set.htm#gafbb906ca5b89ec43fdb0e3a14d1df1e7" title="Sets the current device.">af::setDevice()</a> </td><td class="markdownTableBodyNone">Set ArrayFire's device from an ArrayFire device ID  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga242cc7dc5dcebc9e695e4fc3faebb91e" title="Set ArrayFire&#39;s active device based on id of type cl_device_id.">afcl::setDeviceId()</a> </td><td class="markdownTableBodyNone">Set ArrayFire's device from a cl_device_id  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga37969cfa49416bbdb25910d15c454d01" title="Set active device using cl_context and cl_device_id.">afcl::setDevice()</a> </td><td class="markdownTableBodyNone">Set ArrayFire's device from a cl_device_id and cl_context  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga1984398db67a52977435e653bb842da7" title="Get a handle to ArrayFire&#39;s OpenCL context.">afcl::getContext()</a> </td><td class="markdownTableBodyNone">Get ArrayFire's current cl_context  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga4bdd87f7ee76ba2ac18a7e1719508d5d" title="Get a handle to ArrayFire&#39;s OpenCL command queue.">afcl::getQueue()</a> </td><td class="markdownTableBodyNone">Get ArrayFire's current cl_command_queue  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga9f00565eb14e9cc9bf9568bac2072d70" title="Get the type of the current device.">afcl::getDeviceType()</a> </td><td class="markdownTableBodyNone">Get the current afcl_device_type  </td></tr>
</table>
<p>Additionally, the OpenCL backend permits the programmer to add and remove custom devices from the ArrayFire device manager. These permit you to attach ArrayFire directly to the OpenCL queue used by other portions of your application.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function </th><th class="markdownTableHeadNone">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga52c81b7227b95ce05c3e8b8efed3a9dc" title="Push user provided device control constructs into the ArrayFire device manager pool.">afcl::addDevice()</a> </td><td class="markdownTableBodyNone">Add a new device to ArrayFire's device manager  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__opencl__mat.htm#ga410026dc3d7b5e8b779c3505578cb097" title="Remove the user provided device control constructs from the ArrayFire device manager pool.">afcl::deleteDevice()</a> </td><td class="markdownTableBodyNone">Remove a device from ArrayFire's device manager  </td></tr>
</table>
<p>Below we provide two worked examples on how ArrayFire can be integrated into new and existing projects.</p>
<h1>Adding custom OpenCL kernels to an existing ArrayFire application</h1>
<p>By default, ArrayFire manages its own context, queue, memory, and creates custom IDs for devices. Thus there is some bookkeeping that needs to be done to integrate your custom OpenCL kernel.</p>
<p>If your kernels can share operate in the same queue as ArrayFire, you should:</p>
<ol type="1">
<li>Add an include for <code><a class="el" href="opencl_8h.htm">af/opencl.h</a></code> to your project</li>
<li>Obtain the OpenCL context, device, and queue used by ArrayFire</li>
<li>Obtain cl_mem references to <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> objects</li>
<li>Load, build, and use your kernels</li>
<li>Return control of <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> memory to ArrayFire</li>
</ol>
<p>Note, ArrayFire uses an in-order queue, thus when ArrayFire and your kernels are operating in the same queue, there is no need to perform any synchronization operations.</p>
<p>This process is best illustrated with a fully worked example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&gt;</span></div>
<div class="line"><span class="comment">// 1. Add the af/opencl.h include to your project</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencl_8h.htm">af/opencl.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define OCL_CHECK(call)                                                     \</span></div>
<div class="line"><span class="preprocessor">    if (cl_int err = (call) != CL_SUCCESS) {                                \</span></div>
<div class="line"><span class="preprocessor">        fprintf(stderr, __FILE__ &quot;(%d):Returned error code %d\n&quot;, __LINE__, \</span></div>
<div class="line"><span class="preprocessor">                err);                                                       \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordtype">size_t</span> length = 10;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create ArrayFire array objects:</span></div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> A = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">af::randu</a>(length, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> B = <a class="code" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">af::constant</a>(0, length, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... additional ArrayFire operations here</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Obtain the device, context, and queue used by ArrayFire</span></div>
<div class="line">    <span class="keyword">static</span> cl_context af_context     = <a class="code" href="group__opencl__mat.htm#ga1984398db67a52977435e653bb842da7">afcl::getContext</a>();</div>
<div class="line">    <span class="keyword">static</span> cl_device_id af_device_id = <a class="code" href="group__opencl__mat.htm#gae40668cc7d19273f449a1628ac438182">afcl::getDeviceId</a>();</div>
<div class="line">    <span class="keyword">static</span> cl_command_queue af_queue = <a class="code" href="group__opencl__mat.htm#ga4bdd87f7ee76ba2ac18a7e1719508d5d">afcl::getQueue</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Obtain cl_mem references to af::array objects</span></div>
<div class="line">    cl_mem* d_A = A.<a class="code" href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236">device</a>&lt;cl_mem&gt;();</div>
<div class="line">    cl_mem* d_B = B.<a class="code" href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236">device</a>&lt;cl_mem&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Load, build, and use your kernels.</span></div>
<div class="line">    <span class="comment">//    For the sake of readability, we have omitted error checking.</span></div>
<div class="line">    <span class="keywordtype">int</span> status = CL_SUCCESS;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A simple copy kernel, uses C++11 syntax for multi-line strings.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* kernel_name = <span class="stringliteral">&quot;copy_kernel&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="namespaceaf.htm#aaa328f52bf7d2de8150575946f73b13b">source</a>      = R<span class="stringliteral">&quot;(</span></div>
<div class="line"><span class="stringliteral">        void __kernel</span></div>
<div class="line"><span class="stringliteral">        copy_kernel(__global float* gA, __global float* gB) {</span></div>
<div class="line"><span class="stringliteral">        int id = get_global_id(0);</span></div>
<div class="line"><span class="stringliteral">        gB[id] = gA[id];</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">    )&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="comment">// Create the program, build the executable, and extract the entry point</span></div>
<div class="line">    <span class="comment">// for the kernel.</span></div>
<div class="line">    cl_program program = clCreateProgramWithSource(af_context, 1, &amp;<a class="code" href="namespaceaf.htm#aaa328f52bf7d2de8150575946f73b13b">source</a>, NULL, &amp;status);</div>
<div class="line">    OCL_CHECK(status);</div>
<div class="line">    OCL_CHECK(clBuildProgram(program, 1, &amp;af_device_id, NULL, NULL, NULL));</div>
<div class="line">    cl_kernel kernel = clCreateKernel(program, kernel_name, &amp;status);</div>
<div class="line">    OCL_CHECK(status);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set arguments and launch your kernels</span></div>
<div class="line">    OCL_CHECK(clSetKernelArg(kernel, 0, <span class="keyword">sizeof</span>(cl_mem), d_A));</div>
<div class="line">    OCL_CHECK(clSetKernelArg(kernel, 1, <span class="keyword">sizeof</span>(cl_mem), d_B));</div>
<div class="line">    OCL_CHECK(clEnqueueNDRangeKernel(af_queue, kernel, 1, NULL, &amp;length, NULL,</div>
<div class="line">                                     0, NULL, NULL));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Return control of af::array memory to ArrayFire</span></div>
<div class="line">    A.<a class="code" href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680">unlock</a>();</div>
<div class="line">    B.<a class="code" href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680">unlock</a>();</div>
<div class="line"> </div>
<div class="line">    assert(af::allTrue&lt;bool&gt;(A == B));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Delete the pointers returned by the device function. This does NOT</span></div>
<div class="line">    <span class="comment">// delete the cl_mem memory and only deletes the pointers</span></div>
<div class="line">    <span class="keyword">delete</span> d_A;</div>
<div class="line">    <span class="keyword">delete</span> d_B;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... resume ArrayFire operations</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Because the device pointers, d_x and d_y, were returned to ArrayFire&#39;s</span></div>
<div class="line">    <span class="comment">// control by the unlock function, there is no need to free them using</span></div>
<div class="line">    <span class="comment">// clReleaseMemObject()</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Free the kernel and program objects because they are created in user</span></div>
<div class="line">    <span class="comment">// code</span></div>
<div class="line">    OCL_CHECK(clReleaseKernel(kernel));</div>
<div class="line">    OCL_CHECK(clReleaseProgram(program));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> If your kernels needs to operate in their own OpenCL queue, the process is essentially identical, except you need to instruct ArrayFire to complete its computations using the <a class="el" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390" title="Blocks until the device is finished processing.">af::sync()</a> function prior to launching your own kernel and ensure your kernels are complete using <code>clFinish</code> (or similar) commands prior to returning control of the memory to ArrayFire:</p>
<ol type="1">
<li>Add an include for <code><a class="el" href="opencl_8h.htm">af/opencl.h</a></code> to your project</li>
<li>Obtain the OpenCL context, device, and queue used by ArrayFire</li>
<li>Obtain cl_mem references to <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> objects</li>
<li>Instruct ArrayFire to finish operations using <a class="el" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390" title="Blocks until the device is finished processing.">af::sync()</a></li>
<li>Load, build, and use your kernels</li>
<li>Instruct OpenCL to finish operations using clFinish() or similar commands.</li>
</ol>
<ol type="1">
<li>Return control of <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> memory to ArrayFire</li>
</ol>
<h1>Adding ArrayFire to an existing OpenCL application</h1>
<p>Adding ArrayFire to an existing OpenCL application is slightly more involved and can be somewhat tricky due to several optimizations we implement. The most important are as follows:</p>
<ul>
<li>ArrayFire assumes control of all memory provided to it.</li>
<li>ArrayFire does not (in general) support in-place memory transactions.</li>
</ul>
<p>We will discuss the implications of these items below. To add ArrayFire to existing code you need to:</p>
<ol type="1">
<li>Add includes</li>
<li>Instruct OpenCL to complete its operations using clFinish (or similar)</li>
<li>Instruct ArrayFire to use the user-created OpenCL Context</li>
<li>Create ArrayFire arrays from OpenCL memory objects</li>
<li>Perform ArrayFire operations on the Arrays</li>
<li>Instruct ArrayFire to finish operations using <a class="el" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390" title="Blocks until the device is finished processing.">af::sync()</a></li>
<li>Obtain cl_mem references for important memory</li>
<li>Continue your OpenCL application</li>
</ol>
<p>To create the <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> objects, you should use one of the following constructors:</p>
<div class="fragment"><div class="line"><span class="comment">// 1D - 3D af::array constructors</span></div>
<div class="line"><span class="keyword">static</span> <a class="code" href="classaf_1_1array.htm">af::array</a>    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, cl_mem buf, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5">af::dtype</a> type, <span class="keywordtype">bool</span> retain=<span class="keyword">false</span>)</div>
<div class="line">static <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim1, cl_mem buf, <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="namespaceaf.htm#a448f59f3b863561e0fbe00f04dbeca1e">dtype</a> type, <span class="keywordtype">bool</span> retain=false)</div>
<div class="line">static <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim1, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim2, cl_mem buf, <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="namespaceaf.htm#a448f59f3b863561e0fbe00f04dbeca1e">dtype</a> type, <span class="keywordtype">bool</span> retain=false)</div>
<div class="line">static <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim1, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim2, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim3, cl_mem buf, <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="namespaceaf.htm#a448f59f3b863561e0fbe00f04dbeca1e">dtype</a> type, <span class="keywordtype">bool</span> retain=false)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// af::array constructor using a dim4 object</span></div>
<div class="line">static <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> (<a class="code" href="namespaceaf.htm">af</a>::dim4 idims, cl_mem buf, <a class="code" href="namespaceaf.htm">af</a>::<a class="code" href="namespaceaf.htm#a448f59f3b863561e0fbe00f04dbeca1e">dtype</a> type, <span class="keywordtype">bool</span> retain=false)</div>
</div><!-- fragment --><p><em>NOTE</em>: With all of these constructors, ArrayFire's memory manager automatically assumes responsibility for any memory provided to it. If you are creating an array from a <code>cl::Buffer</code>, you should specify <code>retain=true</code> to ensure your memory is not deallocated if your <code>cl::Buffer</code> were to go out of scope. We use this technique in the example below. If you do not wish for ArrayFire to manage your memory, you may call the <code>array::unlock()</code> function and manage the memory yourself; however, if you do so, please be cautious not to call <code>clReleaseMemObj</code> on a <code>cl_mem</code> when ArrayFire might be using it!</p>
<p>The eight steps above are best illustrated using a fully-worked example. Below we use the OpenCL C++ API and omit error checking to keep the code readable.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&gt;</span></div>
<div class="line"><span class="comment">// 1. Add the af/opencl.h include to your project</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencl_8h.htm">af/opencl.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// definitions required by cl2.hpp</span></div>
<div class="line"><span class="preprocessor">#define CL_HPP_ENABLE_EXCEPTIONS</span></div>
<div class="line"><span class="preprocessor">#define CL_HPP_TARGET_OPENCL_VERSION 120</span></div>
<div class="line"><span class="preprocessor">#define CL_HPP_MINIMUM_OPENCL_VERSION 120</span></div>
<div class="line"><span class="preprocessor">#include &lt;CL/cl2.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Add arrayfire.h and af/opencl.h to your application</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="opencl_8h.htm">af/opencl.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> std::vector;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Set up the OpenCL context, device, and queues</span></div>
<div class="line">    cl::Context context;</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        context = cl::Context(CL_DEVICE_TYPE_ALL);</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> cl::Error&amp; err) {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Exiting creating context&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    vector&lt;cl::Device&gt; devices = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;();</div>
<div class="line">    <span class="keywordflow">if</span> (devices.empty()) {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Exiting. No devices found&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">    }</div>
<div class="line">    cl::Device device = devices[0];</div>
<div class="line">    cl::CommandQueue queue(context, device);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a buffer of size 10 filled with ones, copy it to the device</span></div>
<div class="line">    <span class="keywordtype">int</span> length = 10;</div>
<div class="line">    vector&lt;float&gt; h_A(length, 1);</div>
<div class="line">    cl::Buffer cl_A(context, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,</div>
<div class="line">                    length * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), h_A.data());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Instruct OpenCL to complete its operations using clFinish (or similar)</span></div>
<div class="line">    queue.finish();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Instruct ArrayFire to use the user-created context</span></div>
<div class="line">    <span class="comment">//    First, create a device from the current OpenCL device + context +</span></div>
<div class="line">    <span class="comment">//    queue</span></div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga52c81b7227b95ce05c3e8b8efed3a9dc">afcl::addDevice</a>(device(), context(), queue());</div>
<div class="line">    <span class="comment">//    Next switch ArrayFire to the device using the device and context as</span></div>
<div class="line">    <span class="comment">//    identifiers:</span></div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga37969cfa49416bbdb25910d15c454d01">afcl::setDevice</a>(device(), context());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Create ArrayFire arrays from OpenCL memory objects</span></div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> af_A = <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">afcl::array</a>(length, cl_A(), <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>, <span class="keyword">true</span>);</div>
<div class="line">    clRetainMemObject(cl_A());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Perform ArrayFire operations on the Arrays</span></div>
<div class="line">    af_A = af_A + <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">af::randu</a>(length);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// NOTE: ArrayFire does not perform the above transaction using in-place</span></div>
<div class="line">    <span class="comment">// memory, thus the underlying OpenCL buffers containing the memory</span></div>
<div class="line">    <span class="comment">// containing memory to probably have changed</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 6. Instruct ArrayFire to finish operations using af::sync</span></div>
<div class="line">    <a class="code" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390">af::sync</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 7. Obtain cl_mem references for important memory</span></div>
<div class="line">    cl_mem* af_mem = af_A.<a class="code" href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236">device</a>&lt;cl_mem&gt;();</div>
<div class="line">    cl_A           = cl::Buffer(*af_mem, <span class="comment">/*retain*/</span> <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">delete</span> af_mem;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 8. Continue your OpenCL application</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --> <h1>Using multiple devices</h1>
<p>If you are using ArrayFire and OpenCL with multiple devices be sure to use <code><a class="el" href="group__opencl__mat.htm#ga52c81b7227b95ce05c3e8b8efed3a9dc" title="Push user provided device control constructs into the ArrayFire device manager pool.">afcl::addDevice</a></code> to add your custom context + device + queue to ArrayFire's device manager. This will let you switch ArrayFire devices using your current <code>cl_device_id</code> and <code>cl_context</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__opencl__mat_htm_ga4bdd87f7ee76ba2ac18a7e1719508d5d"><div class="ttname"><a href="group__opencl__mat.htm#ga4bdd87f7ee76ba2ac18a7e1719508d5d">afcl::getQueue</a></div><div class="ttdeci">static cl_command_queue getQueue(bool retain=false)</div><div class="ttdoc">Get a handle to ArrayFire's OpenCL command queue.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00195">opencl.h:195</a></div></div>
<div class="ttc" id="adefines_8h_htm_a7f026aa801b1fa6b85b0d992b414cccb"><div class="ttname"><a href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a></div><div class="ttdeci">long long dim_t</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00056">defines.h:56</a></div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga37969cfa49416bbdb25910d15c454d01"><div class="ttname"><a href="group__opencl__mat.htm#ga37969cfa49416bbdb25910d15c454d01">afcl::setDevice</a></div><div class="ttdeci">static void setDevice(cl_device_id dev, cl_context ctx)</div><div class="ttdoc">Set active device using cl_context and cl_device_id.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00258">opencl.h:258</a></div></div>
<div class="ttc" id="agroup__data__func__constant_htm_ga3c58da8ca31ae6c871379aeb587b8b0d"><div class="ttname"><a href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">af::constant</a></div><div class="ttdeci">array constant(T val, const dim4 &amp;dims, const dtype ty=(af_dtype) dtype_traits&lt; T &gt;::ctype)</div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga1984398db67a52977435e653bb842da7"><div class="ttname"><a href="group__opencl__mat.htm#ga1984398db67a52977435e653bb842da7">afcl::getContext</a></div><div class="ttdeci">static cl_context getContext(bool retain=false)</div><div class="ttdoc">Get a handle to ArrayFire's OpenCL context.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00179">opencl.h:179</a></div></div>
<div class="ttc" id="anamespaceaf_htm_a448f59f3b863561e0fbe00f04dbeca1e"><div class="ttname"><a href="namespaceaf.htm#a448f59f3b863561e0fbe00f04dbeca1e">af::dtype</a></div><div class="ttdeci">af_dtype dtype</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00549">defines.h:549</a></div></div>
<div class="ttc" id="aclassaf_1_1array_htm"><div class="ttname"><a href="classaf_1_1array.htm">af::array</a></div><div class="ttdoc">A multi dimensional data container.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.htm#l00035">array.h:35</a></div></div>
<div class="ttc" id="anamespaceaf_htm"><div class="ttname"><a href="namespaceaf.htm">af</a></div><div class="ttdef"><b>Definition:</b> <a href="algorithm_8h_source.htm#l00014">algorithm.h:15</a></div></div>
<div class="ttc" id="anamespaceaf_htm_aaa328f52bf7d2de8150575946f73b13b"><div class="ttname"><a href="namespaceaf.htm#aaa328f52bf7d2de8150575946f73b13b">af::source</a></div><div class="ttdeci">af_source source</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00550">defines.h:550</a></div></div>
<div class="ttc" id="agroup__opencl__mat_htm_gae40668cc7d19273f449a1628ac438182"><div class="ttname"><a href="group__opencl__mat.htm#gae40668cc7d19273f449a1628ac438182">afcl::getDeviceId</a></div><div class="ttdeci">static cl_device_id getDeviceId()</div><div class="ttdoc">Get the device ID for ArrayFire's current active device.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00207">opencl.h:207</a></div></div>
<div class="ttc" id="aclassaf_1_1array_htm_adadd8fc5a8adad8b3b833eb6a4244236"><div class="ttname"><a href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236">af::array::device</a></div><div class="ttdeci">T * device() const</div><div class="ttdoc">Get the device pointer from the array and lock the buffer in memory manager.</div></div>
<div class="ttc" id="adefines_8h_htm_a023d8ac325fb14f1712a52fb0940b1d5"><div class="ttname"><a href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5">af_dtype</a></div><div class="ttdeci">af_dtype</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00210">defines.h:210</a></div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga52c81b7227b95ce05c3e8b8efed3a9dc"><div class="ttname"><a href="group__opencl__mat.htm#ga52c81b7227b95ce05c3e8b8efed3a9dc">afcl::addDevice</a></div><div class="ttdeci">static void addDevice(cl_device_id dev, cl_context ctx, cl_command_queue que)</div><div class="ttdoc">Push user provided device control constructs into the ArrayFire device manager pool.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00244">opencl.h:244</a></div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga5434aaf76be37fae92ac5086315516f0"><div class="ttname"><a href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">afcl::array</a></div><div class="ttdeci">static af::array array(af::dim4 idims, cl_mem buf, af::dtype type, bool retain=false)</div><div class="ttdoc">Create an af::array object from an OpenCL cl_mem buffer.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00327">opencl.h:327</a></div></div>
<div class="ttc" id="agroup__random__func__randu_htm_gabe9a79d7b21f0a8fb7ace6920ead4772"><div class="ttname"><a href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">af::randu</a></div><div class="ttdeci">AFAPI array randu(const dim4 &amp;dims, const dtype ty, randomEngine &amp;r)</div></div>
<div class="ttc" id="aarrayfire_8h_htm"><div class="ttname"><a href="arrayfire_8h.htm">arrayfire.h</a></div></div>
<div class="ttc" id="agroup__device__func__sync_htm_ga8c5d51841cf4f2ddbdd6a3146cf2b390"><div class="ttname"><a href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390">af::sync</a></div><div class="ttdeci">AFAPI void sync(const int device=-1)</div><div class="ttdoc">Blocks until the device is finished processing.</div></div>
<div class="ttc" id="aclassaf_1_1array_htm_abc83498cc8bf3655094e2f4273861680"><div class="ttname"><a href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680">af::array::unlock</a></div><div class="ttdeci">void unlock() const</div><div class="ttdoc">Unlocks the device buffer in the memory manager.</div></div>
<div class="ttc" id="aopencl_8h_htm"><div class="ttname"><a href="opencl_8h.htm">opencl.h</a></div></div>
<div class="ttc" id="adefines_8h_htm_a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b"><div class="ttname"><a href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a></div><div class="ttdeci">@ f32</div><div class="ttdoc">32-bit floating point values</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00211">defines.h:211</a></div></div>
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-130950618-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "https://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "https://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
