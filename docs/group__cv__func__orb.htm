<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>orb</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="afw.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/>
  </td>
	 <td id="gsearch">
   <div><script>
	    (function() {
        var cx = '004356362924927882526:zup3ehe-7bs';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
	    var s = document.getElementsByTagName('script')[0];
	    s.parentNode.insertBefore(gcse, s);
	  })();
  </script>
  <gcse:search></gcse:search>
</div>
	 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.htm"><span>Tutorials</span></a></li>
      <li class="current"><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__cv__func__orb.htm','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">orb<div class="ingroups"><a class="el" href="group__arrayfire__func.htm">Complete List of ArrayFire Functions</a><a class="el" href="group__func__categories.htm">ArrayFire Functions by Category</a> &raquo; <a class="el" href="group__cv__mat.htm">Computer Vision</a> &raquo;  &#124; <a class="el" href="group__featdescriptor__mat.htm">Feature descriptors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ORB Feature descriptor.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga174060bf74dfc2fce8db125d0d6b036d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cv__func__orb.htm#ga174060bf74dfc2fce8db125d0d6b036d">orb</a> (<a class="el" href="classaf_1_1features.htm">features</a> &amp;feat, <a class="el" href="classaf_1_1array.htm">array</a> &amp;desc, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;image, const float fast_thr=20.f, const unsigned max_feat=400, const float scl_fctr=1.5f, const unsigned levels=4, const bool blur_img=false)</td></tr>
<tr class="memdesc:ga174060bf74dfc2fce8db125d0d6b036d"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface for ORB feature descriptor.  <a href="group__cv__func__orb.htm#ga174060bf74dfc2fce8db125d0d6b036d">More...</a><br /></td></tr>
<tr class="separator:ga174060bf74dfc2fce8db125d0d6b036d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b80df1c1f7d95ed1a52b73ba21d4d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cv__func__orb.htm#ga3b80df1c1f7d95ed1a52b73ba21d4d07">af_orb</a> (<a class="el" href="features_8h.htm#a294c8f0e20b10dfc4f4f18566dba06bc">af_features</a> *feat, <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *desc, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> in, const float fast_thr, const unsigned max_feat, const float scl_fctr, const unsigned levels, const bool blur_img)</td></tr>
<tr class="memdesc:ga3b80df1c1f7d95ed1a52b73ba21d4d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface for ORB feature descriptor.  <a href="#ga3b80df1c1f7d95ed1a52b73ba21d4d07">More...</a><br /></td></tr>
<tr class="separator:ga3b80df1c1f7d95ed1a52b73ba21d4d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ORB Feature descriptor. </p>
<p>Extract ORB descriptors from FAST features that hold higher Harris responses. FAST does not compute orientation, thus, orientation of features is calculated using the intensity centroid. As FAST is also not multi-scale enabled, a multi-scale pyramid is calculated by downsampling the input image multiple times followed by FAST feature detection on each scale. </p><hr/>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3b80df1c1f7d95ed1a52b73ba21d4d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b80df1c1f7d95ed1a52b73ba21d4d07">&#9670;&nbsp;</a></span>af_orb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_orb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="features_8h.htm#a294c8f0e20b10dfc4f4f18566dba06bc">af_features</a> *&#160;</td>
          <td class="paramname"><em>feat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>fast_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>max_feat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scl_fctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blur_img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface for ORB feature descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">feat</td><td>af_features struct composed of arrays for x and y coordinates, score, orientation and size of selected features </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>Nx8 array containing extracted descriptors, where N is the number of selected features </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>array containing a grayscale image (color images are not supported) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_thr</td><td>FAST threshold for which a pixel of the circle around the central pixel is considered to be brighter or darker </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_feat</td><td>maximum number of features to hold (will only keep the max_feat features with higher Harris responses) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scl_fctr</td><td>factor to downsample the input image, meaning that each level will hold prior level dimensions divided by scl_fctr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">levels</td><td>number of levels to be computed for the image pyramid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blur_img</td><td>blur image with a Gaussian filter with sigma=2 before computing descriptors to increase robustness against noise if true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga174060bf74dfc2fce8db125d0d6b036d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174060bf74dfc2fce8db125d0d6b036d">&#9670;&nbsp;</a></span>orb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> void af::orb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaf_1_1features.htm">features</a> &amp;&#160;</td>
          <td class="paramname"><em>feat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>fast_thr</em> = <code>20.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>max_feat</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scl_fctr</em> = <code>1.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>levels</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blur_img</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface for ORB feature descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">feat</td><td>features object composed of arrays for x and y coordinates, score, orientation and size of selected features </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>Nx8 array containing extracted descriptors, where N is the number of selected features </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>array containing a grayscale image (color images are not supported) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fast_thr</td><td>FAST threshold for which a pixel of the circle around the central pixel is considered to be brighter or darker </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_feat</td><td>maximum number of features to hold (will only keep the max_feat features with higher Harris responses) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scl_fctr</td><td>factor to downsample the input image, meaning that each level will hold prior level dimensions divided by scl_fctr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">levels</td><td>number of levels to be computed for the image pyramid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blur_img</td><td>blur image with a Gaussian filter with sigma=2 before computing descriptors to increase robustness against noise if true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5076919-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
