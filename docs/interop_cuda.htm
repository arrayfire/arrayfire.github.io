<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: Interoperability with CUDA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/></td>
   <td id="gsearch">
       <div><script>
             (function() {
                 var cx = '004356362924927882526:zup3ehe-7bs';
                 var gcse = document.createElement('script');
                 gcse.type = 'text/javascript';
                 gcse.async = true;
                 gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//www.google.com/cse/cse.js?cx=' + cx;
                 var s = document.getElementsByTagName('script')[0];
                 s.parentNode.insertBefore(gcse, s);
             })();
       </script>
       <gcse:search></gcse:search>
       <div>
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('interop_cuda.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interoperability with CUDA </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Although ArrayFire is quite extensive, there remain many cases in which you may want to write custom kernels in CUDA or <a class="el" href="interop_opencl.htm">OpenCL</a>. For example, you may wish to add ArrayFire to an existing code base to increase your productivity, or you may need to supplement ArrayFire's functionality with your own custom implementation of specific algorithms.</p>
<p>ArrayFire manages its own memory, runs within its own CUDA stream, and creates custom IDs for devices. As such, most of the interoperability functions focus on reducing potential synchronization conflicts between ArrayFire and CUDA.</p>
<h1>Basics</h1>
<p>It is fairly straightforward to interface ArrayFire with your own custom CUDA code. ArrayFire provides several functions to ease this process including:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function </th><th class="markdownTableHeadNone">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array(...)</a> </td><td class="markdownTableBodyNone">Construct an ArrayFire Array from device memory  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236" title="Get the device pointer from the array and lock the buffer in memory manager.">af::array.device()</a> </td><td class="markdownTableBodyNone">Obtain a pointer to the device memory (implies <code>lock()</code>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm#a0af0c6e3920cd67025211889c98807db" title="Locks the device buffer in the memory manager.">af::array.lock()</a> </td><td class="markdownTableBodyNone">Removes ArrayFire's control of a device memory pointer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680" title="Unlocks the device buffer in the memory manager.">af::array.unlock()</a> </td><td class="markdownTableBodyNone">Restores ArrayFire's control over a device memory pointer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__device__func__get.htm#ga4dfe3f90475b735384f8b28cf2b19a11" title="Gets the current device ID.">af::getDevice()</a> </td><td class="markdownTableBodyNone">Gets the current ArrayFire device ID  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__device__func__set.htm#gafbb906ca5b89ec43fdb0e3a14d1df1e7" title="Sets the current device.">af::setDevice()</a> </td><td class="markdownTableBodyNone">Switches ArrayFire to the specified device  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__cuda__mat.htm#ga59b163ea391ea856a25693e2567b0ce5" title="Get the native device id of the CUDA device with id in ArrayFire context.">afcu::getNativeId()</a> </td><td class="markdownTableBodyNone">Converts an ArrayFire device ID to a CUDA device ID  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__cuda__mat.htm#ga6178cfc0ae2dbc311e9462d67d0f6c32" title="Set the CUDA device with given native id as the active device for ArrayFire.">afcu::setNativeId()</a> </td><td class="markdownTableBodyNone">Switches ArrayFire to the specified CUDA device ID  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__cuda__mat.htm#gaec1dc4c2aa935dc61889f23248c8450d" title="Get the stream for the CUDA device with id in ArrayFire context.">afcu::getStream()</a> </td><td class="markdownTableBodyNone">Get the current CUDA stream used by ArrayFire  </td></tr>
</table>
<p>Below we provide two worked examples on how ArrayFire can be integrated into new and existing projects.</p>
<h1>Adding custom CUDA kernels to an existing ArrayFire application</h1>
<p>By default, ArrayFire manages its own memory and operates in its own CUDA stream. Thus there is a slight amount of bookkeeping that needs to be done in order to integrate your custom CUDA kernel.</p>
<p>If your kernels can share the ArrayFire CUDA stream, you should:</p>
<ol type="1">
<li>Include the 'af/afcuda.h' header in your source code</li>
<li>Use ArrayFire as normal</li>
<li>Ensure any JIT kernels have executed using <code><a class="el" href="group__data__mat.htm#ga121545fb637db409a523862cdb8ffe39" title="Evaluate an expression (nonblocking).">af::eval()</a></code></li>
<li>Obtain device pointers from ArrayFire array objects using <code>array::device()</code></li>
<li>Determine ArrayFire's CUDA stream</li>
<li>Set arguments and run your kernel in ArrayFire's stream</li>
<li>Return control of <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> memory to ArrayFire</li>
<li>Compile with <code>nvcc</code>, linking with the <code>afcuda</code> library.</li>
</ol>
<p>Notice that since ArrayFire and your kernels are sharing the same CUDA stream, there is no need to perform any synchronization operations as operations within a stream are executed in order.</p>
<p>This process is best illustrated with a fully worked example:</p>
<div class="fragment"><div class="line"><span class="comment">// 1. Add includes</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda_8h.htm">af/cuda.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Use ArrayFire as normal</span></div>
<div class="line">    <span class="keywordtype">size_t</span> num = 10;</div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> x = <a class="code" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">af::constant</a>(0, num);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... many ArrayFire operaitons here</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Ensure any JIT kernels have executed</span></div>
<div class="line">    x.<a class="code" href="classaf_1_1array.htm#a6a8d7156cd3c66a9ca9f0f2688ee9f72">eval</a>();</div>
<div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run a custom CUDA kernel in the ArrayFire CUDA stream</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Obtain device pointers from ArrayFire array objects using</span></div>
<div class="line">    <span class="comment">//    the array::device() function:</span></div>
<div class="line">    <span class="keywordtype">float</span> *d_x = x.<a class="code" href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236">device</a>&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Determine ArrayFire&#39;s CUDA stream</span></div>
<div class="line">    <span class="keywordtype">int</span> af_id = <a class="code" href="group__device__func__get.htm#ga4dfe3f90475b735384f8b28cf2b19a11">af::getDevice</a>();</div>
<div class="line">    <span class="keywordtype">int</span> cuda_id = <a class="code" href="group__cuda__mat.htm#ga59b163ea391ea856a25693e2567b0ce5">afcu::getNativeId</a>(af_id);</div>
<div class="line">    cudaStream_t af_cuda_stream = <a class="code" href="group__cuda__mat.htm#gaec1dc4c2aa935dc61889f23248c8450d">afcu::getStream</a>(cuda_id);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 6. Set arguments and run your kernel in ArrayFire&#39;s stream</span></div>
<div class="line">    <span class="comment">//    Here launch with 10 blocks of 10 threads</span></div>
<div class="line">    increment&lt;&lt;&lt;1, num, 0, af_cuda_stream&gt;&gt;&gt;(d_x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 7. Return control of af::array memory to ArrayFire using</span></div>
<div class="line">    <span class="comment">//    the array::unlock() function:</span></div>
<div class="line">    x.<a class="code" href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680">unlock</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... resume ArrayFire operations</span></div>
<div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Because the device pointer `d_x` was returned to ArrayFire&#39;s</span></div>
<div class="line">    <span class="comment">// control by the unlock function, there is no need to free them using</span></div>
<div class="line">    <span class="comment">// cudaFree()</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If your kernels needs to operate in their own CUDA stream, the process is essentially identical, except you need to instruct ArrayFire to complete its computations using the <a class="el" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390" title="Blocks until the device is finished processing.">af::sync()</a> function prior to launching your own kernel and ensure your kernels are complete using <code>cudaDeviceSynchronize()</code> (or similar) commands prior to returning control of the memory to ArrayFire:</p>
<ol type="1">
<li>Include the 'af/afcuda.h' header in your source code</li>
<li>Use ArrayFire as normal</li>
<li>Ensure any JIT kernels have executed using <code><a class="el" href="group__data__mat.htm#ga121545fb637db409a523862cdb8ffe39" title="Evaluate an expression (nonblocking).">af::eval()</a></code></li>
<li>Instruct ArrayFire to finish operations using <a class="el" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390" title="Blocks until the device is finished processing.">af::sync()</a></li>
<li>Obtain device pointers from ArrayFire array objects using</li>
<li>Determine ArrayFire's CUDA stream</li>
<li>Set arguments and run your kernel in your custom stream</li>
<li>Ensure CUDA operations have finished using <code>cudaDeviceSyncronize()</code> or similar commands.</li>
<li>Return control of <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> memory to ArrayFire</li>
<li>Compile with <code>nvcc</code>, linking with the <code>afcuda</code> library.</li>
</ol>
<h1>Adding ArrayFire to an existing CUDA application</h1>
<p>Adding ArrayFire to an existing CUDA application is slightly more involved and can be somewhat tricky due to several optimizations we implement. The most important are as follows:</p>
<ul>
<li>ArrayFire assumes control of all memory provided to it.</li>
<li>ArrayFire does not (in general) support in-place memory transactions.</li>
</ul>
<p>We will discuss the implications of these items below. To add ArrayFire to existing code you need to:</p>
<ol type="1">
<li>Include <code><a class="el" href="arrayfire_8h.htm">arrayfire.h</a></code> and <code><a class="el" href="cuda_8h.htm">af/cuda.h</a></code> in your source file</li>
<li>Finish any pending CUDA operations (e.g. use cudaDeviceSynchronize() or similar stream functions)</li>
<li>Create ArrayFire arrays from existing CUDA pointers</li>
<li>Perform operations on ArrayFire arrays</li>
<li>Instruct ArrayFire to finish operations using <a class="el" href="group__data__mat.htm#ga121545fb637db409a523862cdb8ffe39" title="Evaluate an expression (nonblocking).">af::eval()</a> and <a class="el" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390" title="Blocks until the device is finished processing.">af::sync()</a></li>
<li>Obtain pointers to important memory</li>
<li>Continue your CUDA application.</li>
<li>Free non-managed memory</li>
<li>Compile and link with the appropriate paths and the <code>-lafcuda</code> flags.</li>
</ol>
<p>To create the <a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container.">af::array</a> objects, you should use one of the following constructors with <code>src=afDevice</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// 1D - 3D af::array constructors</span></div>
<div class="line"><a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">af::array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <span class="keyword">const</span> T *pointer, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6">af::source</a> src=<a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba">afHost</a>)</div>
<div class="line"><a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">af::array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim1, <span class="keyword">const</span> T *pointer, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6">af::source</a> src=<a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba">afHost</a>)</div>
<div class="line"><a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">af::array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim1, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim2, <span class="keyword">const</span> T *pointer, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6">af::source</a> src=<a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba">afHost</a>)</div>
<div class="line"><a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">af::array</a> (<a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim0, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim1, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim2, <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> dim3, <span class="keyword">const</span> T *pointer, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6">af::source</a> src=<a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba">afHost</a>)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// af::array constructor using a dim4 object</span></div>
<div class="line"><a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">af::array</a> (<span class="keyword">const</span> dim4 &amp;dims, <span class="keyword">const</span> T *pointer, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6">af::source</a> src=<a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba">afHost</a>)</div>
</div><!-- fragment --><p><em>NOTE</em>: With all of these constructors, ArrayFire's memory manager automatically assumes responsibility for any memory provided to it. Thus ArrayFire could free or reuse the memory at any later time. If this behavior is not desired, you may call <code>array::unlock()</code> and manage the memory yourself. However, if you do so, please be cautious not to free memory when ArrayFire might be using it!</p>
<p>The seven steps above are best illustrated using a fully-worked example:</p>
<div class="fragment"><div class="line"><span class="comment">// 1. Add includes</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda_8h.htm">af/cuda.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create and populate CUDA memory objects</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> elements = 100;</div>
<div class="line">    <span class="keywordtype">size_t</span> size = elements * <span class="keyword">sizeof</span>(float);</div>
<div class="line">    <span class="keywordtype">float</span> *cuda_A;</div>
<div class="line">    cudaMalloc((<span class="keywordtype">void</span>**) &amp;cuda_A, size);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... perform many CUDA operations here</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Finish any pending CUDA operations</span></div>
<div class="line">    cudaDeviceSynchronize();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create ArrayFire arrays from existing CUDA pointers.</span></div>
<div class="line">    <span class="comment">//    Be sure to specify that the memory type is afDevice.</span></div>
<div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> d_A(elements, cuda_A, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a4994dad30a526a10d0e7e3ed8ec47dc2">afDevice</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// NOTE: ArrayFire now manages cuda_A</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Perform operations on the ArrayFire Arrays.</span></div>
<div class="line">    d_A = d_A * 2;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// NOTE: ArrayFire does not perform the above transaction using</span></div>
<div class="line">    <span class="comment">// in-place memory, thus the pointers containing memory to d_A have</span></div>
<div class="line">    <span class="comment">// likely changed.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Instruct ArrayFire to finish pending operations using eval and sync.</span></div>
<div class="line">    <a class="code" href="group__data__mat.htm#ga121545fb637db409a523862cdb8ffe39">af::eval</a>(d_A);</div>
<div class="line">    <a class="code" href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390">af::sync</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 6. Get pointers to important memory objects.</span></div>
<div class="line">    <span class="comment">//    Once device is called, ArrayFire will not manage the memory.</span></div>
<div class="line">    <span class="keywordtype">float</span> * outputValue = d_A.device&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 7. continue CUDA application as normal</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 8. Free non-managed memory</span></div>
<div class="line">    <span class="comment">//    We removed outputValue from ArrayFire&#39;s control, we need to free it</span></div>
<div class="line">    cudaFree(outputValue);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Using multiple devices</h1>
<p>If you are using multiple devices with ArrayFire and CUDA kernels, there is one "gotcha" of which you should be aware. ArrayFire implements its own internal order of compute devices, thus a CUDA device ID may not be the same as an ArrayFire device ID. Thus when switching between devices it is important that you use our interoperability functions to get/set the correct device IDs. Below is a quick listing of the various functions needed to switch between devices along with some disambiguation as to the device identifiers used with each function:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function </th><th class="markdownTableHeadNone">ID Type </th><th class="markdownTableHeadNone">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cudaGetDevice() </td><td class="markdownTableBodyNone">CUDA </td><td class="markdownTableBodyNone">Gets the current CUDA device ID  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cudaSetDevice() </td><td class="markdownTableBodyNone">CUDA </td><td class="markdownTableBodyNone">Sets the current CUDA device  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__device__func__get.htm#ga4dfe3f90475b735384f8b28cf2b19a11" title="Gets the current device ID.">af::getDevice()</a> </td><td class="markdownTableBodyNone">AF </td><td class="markdownTableBodyNone">Gets the current ArrayFire device ID  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__device__func__set.htm#gafbb906ca5b89ec43fdb0e3a14d1df1e7" title="Sets the current device.">af::setDevice()</a> </td><td class="markdownTableBodyNone">AF </td><td class="markdownTableBodyNone">Sets the current ArrayFire device  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__cuda__mat.htm#ga59b163ea391ea856a25693e2567b0ce5" title="Get the native device id of the CUDA device with id in ArrayFire context.">afcu::getNativeId()</a> </td><td class="markdownTableBodyNone">AF -&gt; CUDA </td><td class="markdownTableBodyNone">Convert an ArrayFire device ID to a CUDA device ID  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__cuda__mat.htm#ga6178cfc0ae2dbc311e9462d67d0f6c32" title="Set the CUDA device with given native id as the active device for ArrayFire.">afcu::setNativeId()</a> </td><td class="markdownTableBodyNone">CUDA -&gt; AF </td><td class="markdownTableBodyNone">Set the current ArrayFire device from a CUDA ID  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="adefines_8h_htm_ab99909561d2b3c97b0f6a0935a6f7cc6"><div class="ttname"><a href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6">af_source</a></div><div class="ttdeci">af_source</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00232">defines.h:232</a></div></div>
<div class="ttc" id="agroup__cuda__mat_htm_gaec1dc4c2aa935dc61889f23248c8450d"><div class="ttname"><a href="group__cuda__mat.htm#gaec1dc4c2aa935dc61889f23248c8450d">afcu::getStream</a></div><div class="ttdeci">static cudaStream_t getStream(int id)</div><div class="ttdoc">Get the stream for the CUDA device with id in ArrayFire context.</div><div class="ttdef"><b>Definition:</b> <a href="cuda_8h_source.htm#l00110">cuda.h:110</a></div></div>
<div class="ttc" id="adefines_8h_htm_a7f026aa801b1fa6b85b0d992b414cccb"><div class="ttname"><a href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a></div><div class="ttdeci">long long dim_t</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00056">defines.h:56</a></div></div>
<div class="ttc" id="agroup__data__func__constant_htm_ga3c58da8ca31ae6c871379aeb587b8b0d"><div class="ttname"><a href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">af::constant</a></div><div class="ttdeci">array constant(T val, const dim4 &amp;dims, const dtype ty=(af_dtype) dtype_traits&lt; T &gt;::ctype)</div></div>
<div class="ttc" id="agroup__device__func__get_htm_ga4dfe3f90475b735384f8b28cf2b19a11"><div class="ttname"><a href="group__device__func__get.htm#ga4dfe3f90475b735384f8b28cf2b19a11">af::getDevice</a></div><div class="ttdeci">AFAPI int getDevice()</div><div class="ttdoc">Gets the current device ID.</div></div>
<div class="ttc" id="aclassaf_1_1array_htm"><div class="ttname"><a href="classaf_1_1array.htm">af::array</a></div><div class="ttdoc">A multi dimensional data container.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.htm#l00035">array.h:35</a></div></div>
<div class="ttc" id="adefines_8h_htm_ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba"><div class="ttname"><a href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a53f55a251b7809ae7b1c40163f24ffba">afHost</a></div><div class="ttdeci">@ afHost</div><div class="ttdoc">Host pointer.</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00235">defines.h:234</a></div></div>
<div class="ttc" id="autil_8h_htm_a6de8e7f9eb3914d1cea66e55e7b791d3"><div class="ttname"><a href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a></div><div class="ttdeci">#define af_print(...)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.htm#l00149">util.h:148</a></div></div>
<div class="ttc" id="agroup__cuda__mat_htm_ga59b163ea391ea856a25693e2567b0ce5"><div class="ttname"><a href="group__cuda__mat.htm#ga59b163ea391ea856a25693e2567b0ce5">afcu::getNativeId</a></div><div class="ttdeci">static int getNativeId(int id)</div><div class="ttdoc">Get the native device id of the CUDA device with id in ArrayFire context.</div><div class="ttdef"><b>Definition:</b> <a href="cuda_8h_source.htm#l00129">cuda.h:129</a></div></div>
<div class="ttc" id="aclassaf_1_1array_htm_a6a8d7156cd3c66a9ca9f0f2688ee9f72"><div class="ttname"><a href="classaf_1_1array.htm#a6a8d7156cd3c66a9ca9f0f2688ee9f72">af::array::eval</a></div><div class="ttdeci">void eval() const</div><div class="ttdoc">Evaluate any JIT expressions to generate data for the array.</div></div>
<div class="ttc" id="adefines_8h_htm_ab99909561d2b3c97b0f6a0935a6f7cc6a4994dad30a526a10d0e7e3ed8ec47dc2"><div class="ttname"><a href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a4994dad30a526a10d0e7e3ed8ec47dc2">afDevice</a></div><div class="ttdeci">@ afDevice</div><div class="ttdoc">Device pointer.</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00233">defines.h:233</a></div></div>
<div class="ttc" id="aclassaf_1_1array_htm_adadd8fc5a8adad8b3b833eb6a4244236"><div class="ttname"><a href="classaf_1_1array.htm#adadd8fc5a8adad8b3b833eb6a4244236">af::array::device</a></div><div class="ttdeci">T * device() const</div><div class="ttdoc">Get the device pointer from the array and lock the buffer in memory manager.</div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga5434aaf76be37fae92ac5086315516f0"><div class="ttname"><a href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">afcl::array</a></div><div class="ttdeci">static af::array array(af::dim4 idims, cl_mem buf, af::dtype type, bool retain=false)</div><div class="ttdoc">Create an af::array object from an OpenCL cl_mem buffer.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00327">opencl.h:327</a></div></div>
<div class="ttc" id="acuda_8h_htm"><div class="ttname"><a href="cuda_8h.htm">cuda.h</a></div></div>
<div class="ttc" id="aarrayfire_8h_htm"><div class="ttname"><a href="arrayfire_8h.htm">arrayfire.h</a></div></div>
<div class="ttc" id="agroup__device__func__sync_htm_ga8c5d51841cf4f2ddbdd6a3146cf2b390"><div class="ttname"><a href="group__device__func__sync.htm#ga8c5d51841cf4f2ddbdd6a3146cf2b390">af::sync</a></div><div class="ttdeci">AFAPI void sync(const int device=-1)</div><div class="ttdoc">Blocks until the device is finished processing.</div></div>
<div class="ttc" id="agroup__data__mat_htm_ga121545fb637db409a523862cdb8ffe39"><div class="ttname"><a href="group__data__mat.htm#ga121545fb637db409a523862cdb8ffe39">af::eval</a></div><div class="ttdeci">array &amp; eval(array &amp;a)</div><div class="ttdoc">Evaluate an expression (nonblocking).</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.htm#l01354">array.h:1354</a></div></div>
<div class="ttc" id="aclassaf_1_1array_htm_abc83498cc8bf3655094e2f4273861680"><div class="ttname"><a href="classaf_1_1array.htm#abc83498cc8bf3655094e2f4273861680">af::array::unlock</a></div><div class="ttdeci">void unlock() const</div><div class="ttdoc">Unlocks the device buffer in the memory manager.</div></div>
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-130950618-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "https://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "https://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
