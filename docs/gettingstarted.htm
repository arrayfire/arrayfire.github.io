<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="afw.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/>
  </td>
	 <td id="gsearch">
   <div><script>
	    (function() {
        var cx = '004356362924927882526:zup3ehe-7bs';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
	    var s = document.getElementsByTagName('script')[0];
	    s.parentNode.insertBefore(gcse, s);
	  })();
  </script>
  <gcse:search></gcse:search>
</div>
	 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.htm"><span>Tutorials</span></a></li>
      <li><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('gettingstarted.htm','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#gettingstarted_datatypes">Supported data types</a></li>
<li class="level1"><a href="#getting_started_af_arrays">Creating and populating an ArrayFire array</a></li>
<li class="level1"><a href="#getting_started_array_properties">ArrayFire array contents, dimensions, and properties</a></li>
<li class="level1"><a href="#getting_started_writing_math">Writing mathematical expressions in ArrayFire</a></li>
<li class="level1"><a href="#getting_started_constants">Mathematical constants</a></li>
<li class="level1"><a href="#getting_started_indexing">Indexing</a></li>
<li class="level1"><a href="#getting_started_memory_access">Getting access to ArrayFire array memory on the host and device</a></li>
<li class="level1"><a href="#getting_started_bitwise_operators">Bitwise operators</a></li>
<li class="level1"><a href="#gettingstarted_api_usage">Using the ArrayFire API in C and C++</a></li>
<li class="level1"><a href="#getting_started_next_steps">What to read next?</a></li>
<li class="level1"><a href="#getting_started_help">Where to go for help?</a></li>
</ul>
</div>
<div class="textblock"><h1>Introduction</h1>
<p>ArrayFire is a high performance software library for parallel computing with an easy-to-use API. ArrayFire abstracts away much of the details of programming parallel architectures by providing a high-level container object, the <a class="el" href="classaf_1_1array.htm">array</a>, that represents data stored on a CPU, GPU, FPGA, or other type of accelerator. This abstraction permits developers to write massively parallel applications in a high-level language where they need not be concerned about low-level optimizations that are frequently required to achieve high throughput on most parallel architectures.</p>
<h1><a class="anchor" id="gettingstarted_datatypes"></a>
Supported data types</h1>
<p>ArrayFire provides one generic container object, the <a class="el" href="classaf_1_1array.htm">array</a> on which functions and mathematical operations are performed. The <code>array</code> can represent one of many different <a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5">basic data types</a>:</p>
<ul>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a> real single-precision (<code>float</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a994ac20239e3eba6122cafb2eb21f23f">c32</a> complex single-precision (<code>cfloat</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5acdbf3e9fd5f3594b523a077f4838e962">f64</a> real double-precision (<code>double</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a782bca2d24c98bee3e5f1787c4165198">c64</a> complex double-precision (<code>cdouble</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a3734f496648357f310306becf43915b3">b8</a> 8-bit boolean values (<code>bool</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a1bd64190677c261a61c640017dbaddf1">s32</a> 32-bit signed integer (<code>int</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a05ef7b967bac0eef5d9712a6803b9f1a">u32</a> 32-bit unsigned integer (<code>unsigned</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5afa33d5748ff04bcd920280e5a3b790c0">u8</a> 8-bit unsigned values (<code>unsigned char</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a2fb596fb851c71689624894525c069e4">s64</a> 64-bit signed integer (<code>intl</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a1b18b7885e1360b6696142284b4b4928">u64</a> 64-bit unsigned integer (<code>uintl</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a98085990ff18bf438d3c839ea4c80bb4">s16</a> 16-bit signed integer (<code>short</code>)</li>
<li><a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5ae817c8a85914a5f150f2739df6b76c57">u16</a> 16-bit unsigned integer (<code>unsigned short</code>)</li>
</ul>
<p>Most of these data types are supported on all modern GPUs; however, some older devices may lack support for double precision arrays. In this case, a runtime error will be generated when the array is constructed.</p>
<p>If not specified otherwise, <code>array</code>s are created as single precision floating point numbers (<code>f32</code>).</p>
<h1><a class="anchor" id="getting_started_af_arrays"></a>
Creating and populating an ArrayFire array</h1>
<p>ArrayFire <a class="el" href="classaf_1_1array.htm">array</a>s represent memory stored on the device. As such, creation and population of an array will consume memory on the device which cannot freed until the <code>array</code> object goes out of scope. As device memory allocation can be expensive, ArrayFire also includes a memory manager which will re-use device memory whenever possible.</p>
<p>Arrays can be created using one of the <a class="el" href="group__construct__mat.htm">array constructors</a>. Below we show how to create 1D, 2D, and 3D arrays with uninitialized values:</p>
<div class="fragment"><div class="line">    <span class="comment">// Arrays may be created using the array constructor and dimensioned</span></div><div class="line">    <span class="comment">// as 1D, 2D, 3D; however, the values in these arrays will be undefined</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> undefined_1D(100);        <span class="comment">// 1D array with 100 elements</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> undefined_2D(10, 100);    <span class="comment">// 2D array of size 10 x 100</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> undefined_3D(10, 10, 10); <span class="comment">// 3D array of size 10 x 10 x 10</span></div></div><!-- fragment --><p> However, uninitialized memory is likely not useful in your application. ArrayFire provides several convenient functions for creating arrays that contain pre-populated values including constants, uniform random numbers, uniform normally distributed numbers, and the identity matrix:</p>
<div class="fragment"><div class="line">    <span class="comment">// Generate an array of size three filled with zeros.</span></div><div class="line">    <span class="comment">// If no data type is specified, ArrayFire defaults to f32.</span></div><div class="line">    <span class="comment">// The constant function generates the data on the device.</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> zeros      = <a class="code" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">constant</a>(0, 3);</div><div class="line"></div><div class="line">    <span class="comment">// Generate a 1x4 array of uniformly distributed [0,1] random numbers</span></div><div class="line">    <span class="comment">// The randu function generates the data on the device.</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> rand1      = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(1, 4);</div><div class="line"></div><div class="line">    <span class="comment">// Generate a 2x2 array (or matrix, if you prefer) of random numbers</span></div><div class="line">    <span class="comment">// sampled from a normal distribution.</span></div><div class="line">    <span class="comment">// The randn function generates data on the device.</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> rand2      = <a class="code" href="group__random__func__randn.htm#ga2e9602d5bcc87204842b634816afa8a4">randn</a>(2, 2);</div><div class="line"></div><div class="line">    <span class="comment">// Generate a 3x3 identity matrix. The data is generated on the device.</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> iden       = <a class="code" href="group__data__func__identity.htm#gafd8247e22fdb50218926d5d9391fa678">identity</a>(3, 3);</div><div class="line"></div><div class="line">    <span class="comment">// Lastly, create a 2x1 array (column vector) of uniformly distributed</span></div><div class="line">    <span class="comment">// 32-bit complex numbers (c32 data type):</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> randcplx   = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(2, 1, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a994ac20239e3eba6122cafb2eb21f23f">c32</a>);</div></div><!-- fragment --><p> A complete list of ArrayFire functions that automatically generate data on the device may be found on the <a class="el" href="group__data__mat.htm">functions to create arrays</a> page. As stated above, the default data type for arrays is <a class="el" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a> (a 32-bit floating point number) unless specified otherwise.</p>
<p>ArrayFire <code>array</code>s may also be populated from data found on the host. For example:</p>
<div class="fragment"><div class="line">    <span class="comment">// Create a six-element array on the host</span></div><div class="line">    <span class="keywordtype">float</span> hA[] = {0, 1, 2, 3, 4, 5};</div><div class="line"></div><div class="line">    <span class="comment">// Which can be copied into an ArrayFire Array using the pointer copy</span></div><div class="line">    <span class="comment">// constructor. Here we copy the data into a 2x3 matrix:</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> A(2, 3, hA);</div><div class="line"></div><div class="line">    <span class="comment">// ArrayFire provides a convenince function for printing array</span></div><div class="line">    <span class="comment">// objects in case you wish to see how the data is stored:</span></div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(A);</div><div class="line"></div><div class="line">    <span class="comment">// This technique can also be used to populate an array with complex</span></div><div class="line">    <span class="comment">// data (stored in {{real, imaginary}, {real, imaginary},  ... } format</span></div><div class="line">    <span class="comment">// as found in C&#39;s complex.h and C++&#39;s &lt;complex&gt;.</span></div><div class="line">    <span class="comment">// Below we create a 3x1 column vector of complex data values:</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> dB(3, 1, (<a class="code" href="namespaceaf.htm#a63e29e484b92e217fe817fe78abc4f5f">cfloat</a>*) hA); <span class="comment">// 3x1 column vector of complex numbers</span></div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(dB);</div><div class="line"></div></div><!-- fragment --><p> ArrayFire also supports array initialization from memory already on the GPU. For example, with CUDA one can populate an <code>array</code> directly using a call to <code>cudaMemcpy</code>:</p>
<div class="fragment"><div class="line">    <span class="comment">// Create an array on the host, copy it into an ArrayFire 2x3 ArrayFire array</span></div><div class="line">    <span class="keywordtype">float</span> host_ptr[] = {0,1,2,3,4,5};</div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> a(2, 3, host_ptr);</div><div class="line"></div><div class="line">    <span class="comment">// Create a CUDA device pointer, populate it with data from the host</span></div><div class="line">    <span class="keywordtype">float</span> *device_ptr;</div><div class="line">    cudaMalloc((<span class="keywordtype">void</span>**)&amp;device_ptr, 6*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line">    cudaMemcpy(device_ptr, host_ptr, 6*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), cudaMemcpyHostToDevice);</div><div class="line"></div><div class="line">    <span class="comment">// Convert the CUDA-allocated device memory into an ArrayFire array:</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> b(2,3, device_ptr, <a class="code" href="defines_8h.htm#ab99909561d2b3c97b0f6a0935a6f7cc6a4994dad30a526a10d0e7e3ed8ec47dc2">afDevice</a>); <span class="comment">// Note: afDevice (default: afHost)</span></div><div class="line">    <span class="comment">// Note that ArrayFire takes ownership over `device_ptr`, so memory will</span></div><div class="line">    <span class="comment">// be freed when `b` id destructed. Do not call cudaFree(device_ptr)!</span></div><div class="line"></div></div><!-- fragment --><p> Similar functionality exists for OpenCL too. If you wish to intermingle ArrayFire with CUDA or OpenCL code, we suggest you consult the <a class="el" href="interop_cuda.htm">CUDA interoperability</a> or <a class="el" href="interop_opencl.htm">OpenCL interoperability</a> pages for detailed instructions.</p>
<h1><a class="anchor" id="getting_started_array_properties"></a>
ArrayFire array contents, dimensions, and properties</h1>
<p>ArrayFire provides several functions to determine various aspects of arrays. This includes functions to print the contents, query the dimensions, and determine various other aspects of arrays.</p>
<p>The <a class="el" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a> function can be used to print arrays that have already been generated or any expression involving arrays:</p>
<div class="fragment"><div class="line">    <span class="comment">// Generate two arrays</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> a = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(2, 2);</div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> b = <a class="code" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">constant</a>(1, 2, 1);</div><div class="line"></div><div class="line">    <span class="comment">// Print them to the console using af_print</span></div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(a);</div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(b);</div><div class="line"></div><div class="line">    <span class="comment">// Print the results of an expression involving arrays:</span></div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(a.col(0) + b + .4);</div></div><!-- fragment --><p> The dimensions of an array may be determined using either a <a class="el" href="classaf_1_1dim4.htm">dim4</a> object or by accessing the dimensions directly using the <a class="el" href="group__method__mat.htm#ga10d14b019693bc98f672ad7c4ac60bac">dims()</a> and <a class="el" href="group__method__mat.htm#gaf44710cddd99a7992a890b6096265041">numdims()</a> functions:</p>
<div class="fragment"><div class="line">    <span class="comment">// Create a 4x5x2 array of uniformly distributed random numbers</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> a = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(4,5,2);</div><div class="line">    <span class="comment">// Determine the number of dimensions using the numdims() function:</span></div><div class="line">    printf(<span class="stringliteral">&quot;numdims(a)  %d\n&quot;</span>,  a.numdims()); <span class="comment">// 3</span></div><div class="line"></div><div class="line">    <span class="comment">// We can also find the size of the individual dimentions using either</span></div><div class="line">    <span class="comment">// the `dims` function:</span></div><div class="line">    printf(<span class="stringliteral">&quot;dims = [%lld %lld]\n&quot;</span>, a.dims(0), a.dims(1)); <span class="comment">// 4,5</span></div><div class="line"></div><div class="line">    <span class="comment">// Or the elements of a dim4 object:</span></div><div class="line">    dim4 dims = a.dims();</div><div class="line">    printf(<span class="stringliteral">&quot;dims = [%lld %lld]\n&quot;</span>, dims[0], dims[1]); <span class="comment">// 4,5</span></div></div><!-- fragment --><p> In addition to dimensions, arrays also carry several properties including methods to determine the underlying type and size (in bytes). You can even determine whether the array is empty, real/complex, a row/column, or a scalar or a vector:</p>
<div class="fragment"><div class="line">    <span class="comment">// Get the type stored in the array. This will be one of the many</span></div><div class="line">    <span class="comment">// `af_dtype`s presented above:</span></div><div class="line">    printf(<span class="stringliteral">&quot;underlying type: %d\n&quot;</span>, a.type());</div><div class="line"></div><div class="line">    <span class="comment">// Arrays also have several conveience functions to determine if</span></div><div class="line">    <span class="comment">// an Array contains complex or real values:</span></div><div class="line">    printf(<span class="stringliteral">&quot;is complex? %d    is real? %d\n&quot;</span>, a.iscomplex(), a.isreal());</div><div class="line"></div><div class="line">    <span class="comment">// if it is a column or row vector</span></div><div class="line">    printf(<span class="stringliteral">&quot;is vector? %d  column? %d  row? %d\n&quot;</span>, a.isvector(), a.iscolumn(), a.isrow());</div><div class="line"></div><div class="line">    <span class="comment">// and whether or not the array is empty and how much memory it takes on</span></div><div class="line">    <span class="comment">// the device:</span></div><div class="line">    printf(<span class="stringliteral">&quot;empty? %d  total elements: %lld  bytes: %zu\n&quot;</span>, a.isempty(), a.elements(), a.bytes());</div></div><!-- fragment --><p> For further information on these capabilities, we suggest you consult the full documentation on the <a class="el" href="classaf_1_1array.htm">array</a>.</p>
<h1><a class="anchor" id="getting_started_writing_math"></a>
Writing mathematical expressions in ArrayFire</h1>
<p>ArrayFire features an intelligent Just-In-Time (JIT) compilation engine that converts expressions using arrays into the smallest number of CUDA/OpenCL kernels. For most operations on arrays, ArrayFire functions like a vector library. That means that an element-wise operation, like <code>c[i] = a[i] + b[i]</code> in C, would be written more concisely without indexing, like <code>c = a + b</code>. When there are multiple expressions involving arrays, ArrayFire's JIT engine will merge them together. This "kernel fusion" technology not only decreases the number of kernel calls, but, more importantly, avoids extraneous global memory operations. Our JIT functionality extends across C/C++ function boundaries and only ends when a non-JIT function is encountered or a synchronization operation is explicitly called by the code.</p>
<p>ArrayFire provides <a class="el" href="group__arith__mat.htm">hundreds of functions</a> for element-wise operations. All of the standard operators (e.g. +,-,*,/) are supported as are most transcendental functions (sin, cos, log, sqrt, etc.). Here are a few examples:</p>
<div class="fragment"><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> R = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(3, 3);</div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(<a class="code" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">constant</a>(1, 3, 3) + <a class="code" href="group__arith__func__cplx.htm#gae13e5ea3c59fb78f17ce00e2ab5c0047">complex</a>(<a class="code" href="group__arith__func__sin.htm#gac6fdb44f59fbbffdc55c9c4af29e08f4">sin</a>(R)));  <span class="comment">// will be c32</span></div><div class="line"></div><div class="line">    <span class="comment">// rescale complex values to unit circle</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> a = <a class="code" href="group__random__func__randn.htm#ga2e9602d5bcc87204842b634816afa8a4">randn</a>(5, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a994ac20239e3eba6122cafb2eb21f23f">c32</a>);</div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(a / <a class="code" href="group__arith__func__abs.htm#ga23aa8c28a5ffa9368cc92abb143f5eaa">abs</a>(a));</div><div class="line"></div><div class="line">    <span class="comment">// calculate L2 norm of vectors</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> X = <a class="code" href="group__random__func__randn.htm#ga2e9602d5bcc87204842b634816afa8a4">randn</a>(3, 4);</div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(<a class="code" href="group__arith__func__sqrt.htm#ga25c678d4cd9e0702bbc93e11d7d516a8">sqrt</a>(<a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">sum</a>(<a class="code" href="group__arith__func__pow.htm#ga299da8cda1458a6cb7adba9718ec613d">pow</a>(X, 2))));     <span class="comment">// norm of every column vector</span></div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(<a class="code" href="group__arith__func__sqrt.htm#ga25c678d4cd9e0702bbc93e11d7d516a8">sqrt</a>(<a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">sum</a>(<a class="code" href="group__arith__func__pow.htm#ga299da8cda1458a6cb7adba9718ec613d">pow</a>(X, 2), 0)));  <span class="comment">// same as above</span></div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(<a class="code" href="group__arith__func__sqrt.htm#ga25c678d4cd9e0702bbc93e11d7d516a8">sqrt</a>(<a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">sum</a>(<a class="code" href="group__arith__func__pow.htm#ga299da8cda1458a6cb7adba9718ec613d">pow</a>(X, 2), 1)));  <span class="comment">// norm of every row vector</span></div></div><!-- fragment --><p> To see the complete list of functions please consult the documentation on <a class="el" href="group__mathfunc__mat.htm">mathematical</a>, <a class="el" href="group__linalg__mat.htm">linear algebra</a>, <a class="el" href="group__signal__mat.htm">signal processing</a>, and <a class="el" href="group__stats__mat.htm">statistics</a>.</p>
<h1><a class="anchor" id="getting_started_constants"></a>
Mathematical constants</h1>
<p>ArrayFire contains several platform-independent constants, like <a class="el" href="namespaceaf.htm#a460631fd3c4d686ad85e199f2a08fe6a">Pi</a>, <a class="el" href="namespaceaf.htm#a6376adaa49cd123a12eda6819a7e4f1e">NaN</a>, and <a class="el" href="namespaceaf.htm#a873d028925215930b231204b50712cdb">Inf</a>. If ArrayFire does not have a constant you need, you can create your own using the <a class="el" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">af::constant</a> array constructor.</p>
<p>Constants can be used in all of ArrayFire's functions. Below we demonstrate their use in element selection and a mathematical expression:</p>
<div class="fragment"><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> A = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(5,5);</div><div class="line">    A(<a class="code" href="group__scan__func__where.htm#ga1e677067915477bc4aec1605d80d9b7b">where</a>(A &gt; .5)) = <a class="code" href="namespaceaf.htm#a6376adaa49cd123a12eda6819a7e4f1e">NaN</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> x = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(10e6), y = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(10e6);</div><div class="line">    <span class="keywordtype">double</span> pi_est = 4 * sum&lt;float&gt;(<a class="code" href="group__arith__func__hypot.htm#ga64b537a8205c867f03c86124a65570a7">hypot</a>(x,y) &lt; 1) / 10e6;</div><div class="line">    printf(<span class="stringliteral">&quot;estimation error: %g\n&quot;</span>, fabs(<a class="code" href="namespaceaf.htm#a460631fd3c4d686ad85e199f2a08fe6a">Pi</a> - pi_est));</div></div><!-- fragment --><p> Please note that our constants may, at times, conflict with macro definitions in standard header files. When this occurs, please refer to our constants using the <code>af::</code> namespace.</p>
<h1><a class="anchor" id="getting_started_indexing"></a>
Indexing</h1>
<p>Like all functions in ArrayFire, indexing is also executed in parallel on the OpenCL/CUDA device. Because of this, indexing becomes part of a JIT operation and is accomplished using parentheses instead of square brackets (i.e. as <code>A(0)</code> instead of <code>A[0]</code>). To index <code><a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a></code>s you may use one or a combination of the following functions:</p>
<ul>
<li>integer scalars</li>
<li><a class="el" href="classaf_1_1seq.htm">seq()</a> representing a linear sequence</li>
<li><a class="el" href="namespaceaf.htm#a923f02ce0a21b98935aaffd645f717e0">end</a> representing the last element of a dimension</li>
<li><a class="el" href="namespaceaf.htm#af5c1188f38105afaf8b3f383492a1c9f">span</a> representing the entire dimension</li>
<li><a class="el" href="group__array__mem__row.htm#gab4b3d8fcff693a861c0748faf06fd65e">row(i)</a> or <a class="el" href="group__array__mem__col.htm#gae54ff0116727d4f4f5f91306c609704e">col(i)</a> specifying a single row/column</li>
<li><a class="el" href="group__array__mem__row.htm#gacb5178c8a2361d0405cc34775e20c3af">rows(first,last)</a> or <a class="el" href="group__array__mem__col.htm#gab4bddfa6cca59628b353964a71e8ec34">cols(first,last)</a> specifying a span of rows or columns</li>
</ul>
<p>Please see the <a class="el" href="indexing.htm">indexing page</a> for several examples of how to use these functions.</p>
<h1><a class="anchor" id="getting_started_memory_access"></a>
Getting access to ArrayFire array memory on the host and device</h1>
<p>Memory in <code><a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a></code>s may be accessed using the <a class="el" href="group__method__mat.htm#ga332e06d4340867375a5e415fc1befc1d">host()</a> and <a class="el" href="group__device__func__device.htm#gadadd8fc5a8adad8b3b833eb6a4244236">device()</a> functions. The <code>host</code> function <em>copies</em> the data from the device and makes it available in a C-style array on the host. As such, it is up to the developer to manage any memory returned by <code>host</code>. The <code>device</code> function returns a pointer/reference to device memory for interoperability with external CUDA/OpenCL kernels. As this memory belongs to ArrayFire, the programmer should not attempt to free/deallocate the pointer. For example, here is how we can interact with both OpenCL and CUDA:</p>
<div class="fragment"><div class="line">    <span class="comment">// Create an array consisting of 3 random numbers</span></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> a = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(3, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Copy an array on the device to the host:</span></div><div class="line">    <span class="keywordtype">float</span> *host_a = a.host&lt;<span class="keywordtype">float</span>&gt;();</div><div class="line">    <span class="comment">// access the host data as a normal array</span></div><div class="line">    printf(<span class="stringliteral">&quot;host_a[2] = %g\n&quot;</span>, host_a[2]);  <span class="comment">// last element</span></div><div class="line">    <span class="comment">// and free memory using freeHost:</span></div><div class="line">    <a class="code" href="group__device__func__free__host.htm#ga0cc924b1055eee26851be4cd7bedee44">freeHost</a>(host_a);</div><div class="line"></div><div class="line">    <span class="comment">// Get access to the device memory for a CUDA kernel</span></div><div class="line">    <span class="keywordtype">float</span> * d_cuda = a.device&lt;<span class="keywordtype">float</span>&gt;();    <span class="comment">// no need to free this</span></div><div class="line">    <span class="keywordtype">float</span> value;</div><div class="line">    cudaMemcpy(&amp;value, d_cuda + 2, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), cudaMemcpyDeviceToHost);</div><div class="line">    printf(<span class="stringliteral">&quot;d_cuda[2] = %g\n&quot;</span>, value);</div><div class="line">    a.unlock(); <span class="comment">// unlock to allow garbage collection if necessary</span></div><div class="line"></div><div class="line">    <span class="comment">// Because OpenCL uses references rather than pointers, accessing memory</span></div><div class="line">    <span class="comment">// is similar, but has a somewhat clunky syntax. For the C-API</span></div><div class="line">    cl_mem d_opencl = (cl_mem) a.device&lt;<span class="keywordtype">float</span>&gt;();</div><div class="line">    <span class="comment">// for the C++ API, you can just wrap this object into a cl::Buffer</span></div><div class="line">    <span class="comment">// after calling clRetainMemObject.</span></div><div class="line"></div></div><!-- fragment --><p> ArrayFire also provides several helper functions for creating <code><a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a></code>s from OpenCL <code>cl_mem</code> references and <code>cl::Buffer</code> objects. See the <code><a class="el" href="opencl_8h.htm">include/af/opencl.h</a></code> file for further information.</p>
<p>Lastly, if you want only the first value from an <code><a class="el" href="classaf_1_1array.htm" title="A multi dimensional data container. ">af::array</a></code> you can use get it using the <a class="el" href="group__method__mat.htm#ga048d77db849d74f18a13dabfd43ce55d">scalar()</a> function:</p>
<div class="fragment"><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> a = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">randu</a>(3);</div><div class="line">    <span class="keywordtype">float</span> val = a.scalar&lt;<span class="keywordtype">float</span>&gt;();</div><div class="line">    printf(<span class="stringliteral">&quot;scalar value: %g\n&quot;</span>, val);</div></div><!-- fragment --> <h1><a class="anchor" id="getting_started_bitwise_operators"></a>
Bitwise operators</h1>
<p>In addition to supporting standard mathematical functions, arrays that contain integer data types also support bitwise operators including and, or, and shift:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> h_A[] = {1, 1, 0, 0, 4, 0, 0, 2, 0};</div><div class="line">    <span class="keywordtype">int</span> h_B[] = {1, 0, 1, 0, 1, 0, 1, 1, 1};</div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> A = <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>(3, 3, h_A), B = <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>(3, 3, h_B);</div><div class="line">    <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(A); <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(B);</div><div class="line"></div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> A_and_B = A &amp; B; <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(A_and_B);</div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a>  A_or_B = A | B; <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(A_or_B);</div><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> A_xor_B = A ^ B; <a class="code" href="util_8h.htm#a6de8e7f9eb3914d1cea66e55e7b791d3">af_print</a>(A_xor_B);</div></div><!-- fragment --> <h1><a class="anchor" id="gettingstarted_api_usage"></a>
Using the ArrayFire API in C and C++</h1>
<p>The ArrayFire API is wrapped into a unified C/C++ header. To use the library simply include the <code><a class="el" href="arrayfire_8h.htm">arrayfire.h</a></code> header file and start coding!</p>
<h2>Sample using the C API</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&gt;</span></div><div class="line"><span class="comment">// Generate random data and sum and print the result</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// generate random values</span></div><div class="line">    <span class="keywordtype">int</span> n = 10000;</div><div class="line">    <a class="code" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> a;</div><div class="line">    <a class="code" href="group__random__func__randu.htm#ga412e2c2f5135bdda218c3487c487d3b5">af_randu</a>(&amp;a, n);</div><div class="line"></div><div class="line">    <span class="comment">// sum all the values</span></div><div class="line">    <span class="keywordtype">float</span> result;</div><div class="line">    <a class="code" href="group__reduce__func__sum.htm#gabc009d04df0faf29ba1e381c7badde58">af_sum_all</a>(&amp;result, a, 0);</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;sum: %g\n&quot;</span>, <a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">sum</a>);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>Sample using the C++ API</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arrayfire_8h.htm">arrayfire.h</a>&gt;</span></div><div class="line"><span class="comment">// Generate random data, sum and print the result.</span></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// Generate 10,000 random values</span></div><div class="line">    <a class="code" href="classaf_1_1array.htm">af::array</a> a = <a class="code" href="group__random__func__randu.htm#gabe9a79d7b21f0a8fb7ace6920ead4772">af::randu</a>(10000);</div><div class="line"></div><div class="line">    <span class="comment">// Sum the values and copy the result to the CPU:</span></div><div class="line">    <span class="keywordtype">double</span> <a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">sum</a> = af::sum&lt;float&gt;(a);</div><div class="line"></div><div class="line">    printf(<span class="stringliteral">&quot;sum: %g\n&quot;</span>, <a class="code" href="group__reduce__func__sum.htm#ga964a8e7e78dd6d8f4d20c17edf82dbf5">sum</a>);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="getting_started_next_steps"></a>
What to read next?</h1>
<p>Now that you have a general introduction to ArrayFire, where do you go from here? In particular you might find these documents useful</p>
<ul>
<li><a class="el" href="using_on_linux.htm">Building an ArrayFire program on Linux</a></li>
<li><a class="el" href="using_on_windows.htm">Building an Arrayfire program on Windows</a></li>
<li><a class="el" href="timing.htm">Timing ArrayFire code</a></li>
</ul>
<h1><a class="anchor" id="getting_started_help"></a>
Where to go for help?</h1>
<ul>
<li>Google Groups: <a href="https://groups.google.com/forum/#!forum/arrayfire-users">https://groups.google.com/forum/#!forum/arrayfire-users</a></li>
<li>ArrayFire Services: <a href="http://arrayfire.com/consulting/">Consulting</a> | <a href="http://arrayfire.com/support/">Support</a> | <a href="http://arrayfire.com/training/">Training</a></li>
<li>ArrayFire Blogs: <a href="http://arrayfire.com/blog/">http://arrayfire.com/blog/</a></li>
<li>Email: <a href="#" onclick="location.href='mai'+'lto:'+'tec'+'hn'+'ica'+'l@'+'arr'+'ay'+'fir'+'e.'+'com'; return false;">techn<span style="display: none;">.nosp@m.</span>ical<span style="display: none;">.nosp@m.</span>@arra<span style="display: none;">.nosp@m.</span>yfir<span style="display: none;">.nosp@m.</span>e.com</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-130950618-1']);
  _gaq.push(['_setDomainName', '.arrayfire.org']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
