<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: svd</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/></td>
   <td id="gsearch">
       <div><script>
             (function() {
                 var cx = '004356362924927882526:zup3ehe-7bs';
                 var gcse = document.createElement('script');
                 gcse.type = 'text/javascript';
                 gcse.async = true;
                 gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//www.google.com/cse/cse.js?cx=' + cx;
                 var s = document.getElementsByTagName('script')[0];
                 s.parentNode.insertBefore(gcse, s);
             })();
       </script>
       <gcse:search></gcse:search>
       <div>
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li class="current"><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lapack__factor__func__svd.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">svd<div class="ingroups"><a class="el" href="group__arrayfire__func.htm">ArrayFire Functions</a> &#124; <a class="el" href="group__func__categories.htm">ArrayFire Functions by Category</a> &raquo; <a class="el" href="group__linalg__mat.htm">Linear Algebra</a> &raquo; <a class="el" href="group__lapack__factor__mat.htm">Matrix factorizations and decompositions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Computes the singular value decomposition of a matrix.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab016ef45fce266ab9545054bea1cb6b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lapack__factor__func__svd.htm#gab016ef45fce266ab9545054bea1cb6b7">svd</a> (<a class="el" href="classaf_1_1array.htm">array</a> &amp;u, <a class="el" href="classaf_1_1array.htm">array</a> &amp;s, <a class="el" href="classaf_1_1array.htm">array</a> &amp;vt, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;in)</td></tr>
<tr class="memdesc:gab016ef45fce266ab9545054bea1cb6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface for SVD decomposition.  <a href="group__lapack__factor__func__svd.htm#gab016ef45fce266ab9545054bea1cb6b7">More...</a><br /></td></tr>
<tr class="separator:gab016ef45fce266ab9545054bea1cb6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab551c4f09090010669e3906988ac8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lapack__factor__func__svd.htm#gaab551c4f09090010669e3906988ac8a1">svdInPlace</a> (<a class="el" href="classaf_1_1array.htm">array</a> &amp;u, <a class="el" href="classaf_1_1array.htm">array</a> &amp;s, <a class="el" href="classaf_1_1array.htm">array</a> &amp;vt, <a class="el" href="classaf_1_1array.htm">array</a> &amp;in)</td></tr>
<tr class="memdesc:gaab551c4f09090010669e3906988ac8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface for SVD decomposition (in-place)  <a href="group__lapack__factor__func__svd.htm#gaab551c4f09090010669e3906988ac8a1">More...</a><br /></td></tr>
<tr class="separator:gaab551c4f09090010669e3906988ac8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76f30656dce9bd67246ec652983ec21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lapack__factor__func__svd.htm#gae76f30656dce9bd67246ec652983ec21">af_svd</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *u, <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *s, <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *vt, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> in)</td></tr>
<tr class="memdesc:gae76f30656dce9bd67246ec652983ec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface for SVD decomposition.  <a href="group__lapack__factor__func__svd.htm#gae76f30656dce9bd67246ec652983ec21">More...</a><br /></td></tr>
<tr class="separator:gae76f30656dce9bd67246ec652983ec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b31f7671bf00143dd992df8d585a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lapack__factor__func__svd.htm#ga80b31f7671bf00143dd992df8d585a2d">af_svd_inplace</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *u, <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *s, <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *vt, <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> in)</td></tr>
<tr class="memdesc:ga80b31f7671bf00143dd992df8d585a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface for SVD decomposition (in-place)  <a href="group__lapack__factor__func__svd.htm#ga80b31f7671bf00143dd992df8d585a2d">More...</a><br /></td></tr>
<tr class="separator:ga80b31f7671bf00143dd992df8d585a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Computes the singular value decomposition of a matrix. </p>
<p>This function factorizes a matrix \(A\) into two unitary matrices, \(U\) and \(V^T\), and a diagonal matrix \(S\), such that \(A = USV^T\). If \(A\) has \(M\) rows and \(N\) columns ( \(M \times N\)), then \(U\) will be \(M \times M\), \(V\) will be \(N \times N\), and \(S\) will be \(M \times N\). However, for \(S\), this function only returns the non-zero diagonal elements as a sorted (in descending order) 1D array.</p>
<p>To reconstruct the original matrix \(A\) from the individual factors, the following code snippet can be used:</p>
<div class="fragment"><div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> U, S, Vt;</div>
<div class="line">    <a class="code" href="group__lapack__factor__func__svd.htm#gab016ef45fce266ab9545054bea1cb6b7">af::svd</a>(U, S, Vt, A);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> MN = <a class="code" href="group__reduce__func__min.htm#ga2b1287d1babb569d28bc6ee1c8e8e1ea">std::min</a>(M, N);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> UU = U(<a class="code" href="namespaceaf.htm#af5c1188f38105afaf8b3f383492a1c9f">span</a>, seq(MN));</div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> SS = <a class="code" href="group__data__func__diag.htm#ga0cf9ea583e513631ed0226aa08ff60da">diag</a>(S, 0, <span class="keyword">false</span>).<a class="code" href="classaf_1_1array.htm#a5822c6bdfbf4ff01f23c4417934b924c">as</a>(ty);</div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> VV = Vt(seq(MN), <a class="code" href="namespaceaf.htm#af5c1188f38105afaf8b3f383492a1c9f">span</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> AA = <a class="code" href="group__blas__func__matmul.htm#ga63306b6ed967bd1055086db862fe885b">matmul</a>(UU, SS, VV);</div>
</div><!-- fragment --><p> When memory is a concern, and \(A\) is dispensable, <a class="el" href="group__lapack__factor__func__svd.htm#gaab551c4f09090010669e3906988ac8a1">svdInPlace()</a> can be used. However, this in-place version is currently limited to input arrays where \(M \geq N\).</p>
<hr  />
 <h2 class="groupheader">Function Documentation</h2>
<a id="gae76f30656dce9bd67246ec652983ec21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae76f30656dce9bd67246ec652983ec21">&#9670;&nbsp;</a></span>af_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface for SVD decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>is the output array containing U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>is the output array containing the diagonal values of sigma, (singular values of the input matrix)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>is the output array containing V^H </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>is the input matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80b31f7671bf00143dd992df8d585a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b31f7671bf00143dd992df8d585a2d">&#9670;&nbsp;</a></span>af_svd_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_svd_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface for SVD decomposition (in-place) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>is the output array containing U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>is the output array containing the diagonal values of sigma, (singular values of the input matrix)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>is the output array containing V^H </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>is the input matrix that will contain random data after this operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently, <code>in</code> is limited to arrays where <code>dim0</code> \(\geq\) <code>dim1</code> </dd>
<dd>
This is best used when minimizing memory usage and <code>in</code> is dispensable </dd></dl>

</div>
</div>
<a id="gab016ef45fce266ab9545054bea1cb6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab016ef45fce266ab9545054bea1cb6b7">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> void af::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface for SVD decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>is the output array containing U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>is the output array containing the diagonal values of sigma, (singular values of the input matrix)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>is the output array containing V^H </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>is the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lin_algebra_2svd_8cpp-example.htm#a3">lin_algebra/svd.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaab551c4f09090010669e3906988ac8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab551c4f09090010669e3906988ac8a1">&#9670;&nbsp;</a></span>svdInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> void af::svdInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>vt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface for SVD decomposition (in-place) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>is the output array containing U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>is the output array containing the diagonal values of sigma, (singular values of the input matrix)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vt</td><td>is the output array containing V^H </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>is the input matrix and will contain random data after this operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently, <code>in</code> is limited to arrays where <code>dim0</code> \(\geq\) <code>dim1</code> </dd>
<dd>
This is best used when minimizing memory usage and <code>in</code> is dispensable </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__blas__func__matmul_htm_ga63306b6ed967bd1055086db862fe885b"><div class="ttname"><a href="group__blas__func__matmul.htm#ga63306b6ed967bd1055086db862fe885b">af::matmul</a></div><div class="ttdeci">AFAPI array matmul(const array &amp;lhs, const array &amp;rhs, const matProp optLhs=AF_MAT_NONE, const matProp optRhs=AF_MAT_NONE)</div><div class="ttdoc">Matrix multiply of two arrays.</div></div>
<div class="ttc" id="aclassaf_1_1array_htm_a5822c6bdfbf4ff01f23c4417934b924c"><div class="ttname"><a href="classaf_1_1array.htm#a5822c6bdfbf4ff01f23c4417934b924c">af::array::as</a></div><div class="ttdeci">const array as(dtype type) const</div><div class="ttdoc">Converts the array into another type.</div></div>
<div class="ttc" id="agroup__data__func__diag_htm_ga0cf9ea583e513631ed0226aa08ff60da"><div class="ttname"><a href="group__data__func__diag.htm#ga0cf9ea583e513631ed0226aa08ff60da">af::diag</a></div><div class="ttdeci">AFAPI array diag(const array &amp;in, const int num=0, const bool extract=true)</div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga5434aaf76be37fae92ac5086315516f0"><div class="ttname"><a href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">afcl::array</a></div><div class="ttdeci">static af::array array(af::dim4 idims, cl_mem buf, af::dtype type, bool retain=false)</div><div class="ttdoc">Create an af::array object from an OpenCL cl_mem buffer.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00327">opencl.h:327</a></div></div>
<div class="ttc" id="anamespaceaf_htm_af5c1188f38105afaf8b3f383492a1c9f"><div class="ttname"><a href="namespaceaf.htm#af5c1188f38105afaf8b3f383492a1c9f">af::span</a></div><div class="ttdeci">AFAPI seq span</div><div class="ttdoc">A special value representing the entire axis of an af::array.</div></div>
<div class="ttc" id="agroup__lapack__factor__func__svd_htm_gab016ef45fce266ab9545054bea1cb6b7"><div class="ttname"><a href="group__lapack__factor__func__svd.htm#gab016ef45fce266ab9545054bea1cb6b7">af::svd</a></div><div class="ttdeci">AFAPI void svd(array &amp;u, array &amp;s, array &amp;vt, const array &amp;in)</div><div class="ttdoc">C++ Interface for SVD decomposition.</div></div>
<div class="ttc" id="agroup__reduce__func__min_htm_ga2b1287d1babb569d28bc6ee1c8e8e1ea"><div class="ttname"><a href="group__reduce__func__min.htm#ga2b1287d1babb569d28bc6ee1c8e8e1ea">af::min</a></div><div class="ttdeci">AFAPI array min(const array &amp;in, const int dim=-1)</div><div class="ttdoc">C++ Interface for minimum values in an array.</div></div>
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-130950618-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
