<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: matmul</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/></td>
   <td id="gsearch">
       <div><script>
             (function() {
                 var cx = '004356362924927882526:zup3ehe-7bs';
                 var gcse = document.createElement('script');
                 gcse.type = 'text/javascript';
                 gcse.async = true;
                 gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//www.google.com/cse/cse.js?cx=' + cx;
                 var s = document.getElementsByTagName('script')[0];
                 s.parentNode.insertBefore(gcse, s);
             })();
       </script>
       <gcse:search></gcse:search>
       <div>
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li class="current"><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__blas__func__matmul.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">matmul<div class="ingroups"><a class="el" href="group__arrayfire__func.htm">ArrayFire Functions</a><a class="el" href="group__func__categories.htm">ArrayFire Functions by Category</a> &raquo; <a class="el" href="group__linalg__mat.htm">Linear Algebra</a> &raquo;  &#124; <a class="el" href="group__blas__mat.htm">BLAS operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix multiplication using array.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga63306b6ed967bd1055086db862fe885b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga63306b6ed967bd1055086db862fe885b">matmul</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a> optLhs=<a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a> optRhs=<a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>)</td></tr>
<tr class="memdesc:ga63306b6ed967bd1055086db862fe885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply of two arrays.  <a href="group__blas__func__matmul.htm#ga63306b6ed967bd1055086db862fe885b">More...</a><br /></td></tr>
<tr class="separator:ga63306b6ed967bd1055086db862fe885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf90230a67ea7a0b4697511dd978b9c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#gadf90230a67ea7a0b4697511dd978b9c7">matmulNT</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs)</td></tr>
<tr class="memdesc:gadf90230a67ea7a0b4697511dd978b9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply of two arrays.  <a href="group__blas__func__matmul.htm#gadf90230a67ea7a0b4697511dd978b9c7">More...</a><br /></td></tr>
<tr class="separator:gadf90230a67ea7a0b4697511dd978b9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6655d7913b35d7e59f7c8560a5368fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga6655d7913b35d7e59f7c8560a5368fbc">matmulTN</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga6655d7913b35d7e59f7c8560a5368fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply of two arrays.  <a href="group__blas__func__matmul.htm#ga6655d7913b35d7e59f7c8560a5368fbc">More...</a><br /></td></tr>
<tr class="separator:ga6655d7913b35d7e59f7c8560a5368fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3e5a6f282ea2c2c32886c95694bb88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga7f3e5a6f282ea2c2c32886c95694bb88">matmulTT</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga7f3e5a6f282ea2c2c32886c95694bb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply of two arrays.  <a href="group__blas__func__matmul.htm#ga7f3e5a6f282ea2c2c32886c95694bb88">More...</a><br /></td></tr>
<tr class="separator:ga7f3e5a6f282ea2c2c32886c95694bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d05bc14538f14713fe3ce65f6841f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga3d05bc14538f14713fe3ce65f6841f44">matmul</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;a, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;b, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;c)</td></tr>
<tr class="memdesc:ga3d05bc14538f14713fe3ce65f6841f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain 2 matrix multiplications.  <a href="group__blas__func__matmul.htm#ga3d05bc14538f14713fe3ce65f6841f44">More...</a><br /></td></tr>
<tr class="separator:ga3d05bc14538f14713fe3ce65f6841f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329f6ec3d910ca0443e4bc6b7cfe129f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga329f6ec3d910ca0443e4bc6b7cfe129f">matmul</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;a, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;b, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;c, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;d)</td></tr>
<tr class="memdesc:ga329f6ec3d910ca0443e4bc6b7cfe129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain 3 matrix multiplications.  <a href="group__blas__func__matmul.htm#ga329f6ec3d910ca0443e4bc6b7cfe129f">More...</a><br /></td></tr>
<tr class="separator:ga329f6ec3d910ca0443e4bc6b7cfe129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0463ae584163128718237b02faf5caf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *C, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> opA, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> opB, const void *alpha, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> A, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> B, const void *beta)</td></tr>
<tr class="memdesc:ga0463ae584163128718237b02faf5caf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS general matrix multiply (GEMM) of two <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> objects.  <a href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">More...</a><br /></td></tr>
<tr class="separator:ga0463ae584163128718237b02faf5caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3f29358b44286d19ff2037547649fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga3f3f29358b44286d19ff2037547649fe">af_matmul</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *out, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> lhs, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> rhs, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> optLhs, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> optRhs)</td></tr>
<tr class="memdesc:ga3f3f29358b44286d19ff2037547649fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply of two <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>.  <a href="group__blas__func__matmul.htm#ga3f3f29358b44286d19ff2037547649fe">More...</a><br /></td></tr>
<tr class="separator:ga3f3f29358b44286d19ff2037547649fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Matrix multiplication using array. </p>
<p>Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p>Batched matrix multiplications are supported. Given below are the supported types of batch operations for any given set of two matrices A and B.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A </th><th class="markdownTableHeadCenter">Size of Input Matrix B </th><th class="markdownTableHeadCenter">Output Matrix Size  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, 1, 1 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
</table>
<p>where M, K, N are dimensions of the matrix and b2, b3 indicate batch size along the respective dimension.</p>
<p>For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
 <h2 class="groupheader">Function Documentation</h2>
<a id="ga0463ae584163128718237b02faf5caf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0463ae584163128718237b02faf5caf7">&#9670;&nbsp;</a></span>af_gemm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>opB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BLAS general matrix multiply (GEMM) of two <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> objects. </p>
<p>This provides a general interface to the BLAS level 3 general matrix multiply (GEMM), which is generally defined as:</p>
<p class="formulaDsp">
\[ C = \alpha * opA(A)opB(B) + \beta * C \]
</p>
<p>where \(\alpha\) (<code>alpha</code>) and \(\beta\) (<code>beta</code>) are both scalars; \(A\) and \(B\) are the matrix multiply operands; and \(opA\) and \(opB\) are noop (if <code>AF_MAT_NONE</code>) or transpose (if <code>AF_MAT_TRANS</code>) operations on \(A\) or \(B\) before the actual GEMM operation. Batched GEMM is supported if at least either \(A\) or \(B\) have more than two dimensions (see <a class="el" href="group__blas__func__matmul.htm#ga63306b6ed967bd1055086db862fe885b">af::matmul</a> for more details on broadcasting). However, only one <code>alpha</code> and one <code>beta</code> can be used for all of the batched matrix operands.</p>
<p>The <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> that <code>out</code> points to can be used both as an input and output. An allocation will be performed if you pass a null <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> handle (i.e. <code>af_array c = 0;</code>). If a valid <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> is passed as \(C\), the operation will be performed on that <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> itself. The C <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> must be the correct type and shape; otherwise, an error will be thrown.</p>
<dl class="section note"><dt>Note</dt><dd>Passing an af_array that has not been initialized to the C array is will cause undefined behavior.</dd></dl>
<p>This example demonstrates the usage of the af_gemm function on two matrices. The \(C\) <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> handle is initialized to zero here, so <a class="el" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a> will perform an allocation.</p>
<div class="fragment"><div class="line">    <a class="code" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> A, B;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> adims[] = {5, 3, 2};</div>
<div class="line">    <a class="code" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> bdims[] = {3, 5, 2};</div>
<div class="line">    <a class="code" href="group__data__func__constant.htm#gafc51b6a98765dd24cd4139f3bde00670">af_constant</a>(&amp;A, 1, 3, adims, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div>
<div class="line">    <a class="code" href="group__data__func__constant.htm#gafc51b6a98765dd24cd4139f3bde00670">af_constant</a>(&amp;B, 1, 3, bdims, <a class="code" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> alpha = 1.f;</div>
<div class="line">    <span class="keywordtype">float</span> beta  = 0.f;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Undefined behavior!</span></div>
<div class="line">    <span class="comment">// af_array undef;</span></div>
<div class="line">    <span class="comment">// af_gemm(&amp;undef, AF_MAT_NONE, AF_MAT_NONE, &amp;alpha, a.get(), b.get(), &amp;beta);</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> C = 0;</div>
<div class="line">    <a class="code" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a>(&amp;C, <a class="code" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="code" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, &amp;alpha, A, B, &amp;beta);</div>
<div class="line">    <span class="comment">// C =</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line"> </div>
</div><!-- fragment --><p> The following example shows how you can write to a previously allocated <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> using the <a class="el" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a> call. Here we are going to use the <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> s from the previous example and index into the first slice. Only the first slice of the original \(C\) af_array will be modified by this operation.</p>
<div class="fragment"><div class="line">    alpha = 1.f;</div>
<div class="line">    beta  = 1.f;</div>
<div class="line">    <a class="code" href="structaf__seq.htm">af_seq</a> first_slice[] = {<a class="code" href="seq_8h.htm#a980be68ab878dfcd59377c9edd6cb22e">af_span</a>, <a class="code" href="seq_8h.htm#a980be68ab878dfcd59377c9edd6cb22e">af_span</a>, {0., 0., 1.}};</div>
<div class="line">    <a class="code" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> Asub, Bsub, Csub;</div>
<div class="line">    <a class="code" href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a>(&amp;Asub, A, 3, first_slice);</div>
<div class="line">    <a class="code" href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a>(&amp;Bsub, B, 3, first_slice);</div>
<div class="line">    <a class="code" href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a>(&amp;Csub, C, 3, first_slice);</div>
<div class="line">    <a class="code" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a>(&amp;Csub, <a class="code" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="code" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, &amp;alpha, Asub, Bsub, &amp;beta);</div>
<div class="line">    <span class="comment">// C =</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>Pointer to the output <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opA</td><td>Operation to perform on A before the multiplication</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opB</td><td>Operation to perform on B before the multiplication</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The alpha value; must be the same type as <code>lhs</code> and <code>rhs</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Left-hand side operand</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right-hand side operand</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The beta value; must be the same type as <code>lhs</code> and <code>rhs</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AF_SUCCESS if the operation is successful. </dd></dl>

</div>
</div>
<a id="ga3f3f29358b44286d19ff2037547649fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3f29358b44286d19ff2037547649fe">&#9670;&nbsp;</a></span>af_matmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_matmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>optLhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>optRhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiply of two <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>. </p>
<p>Performs a matrix multiplication on two arrays (lhs, rhs).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to the output <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A 2D matrix <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A 2D matrix <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optLhs</td><td>Transpose left hand side before the function is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optRhs</td><td>Transpose right hand side before the function is performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AF_SUCCESS if the process is successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><b> The following applies for Sparse-Dense matrix multiplication.</b> </dd>
<dd>
This function can be used with one sparse input. The sparse input must always be the <code>lhs</code> and the dense matrix must be <code>rhs</code>. </dd>
<dd>
The sparse array can only be of <a class="el" href="defines_8h.htm#a75e1422a62a43dc1ce727ccfb850600fa33553814922263702c5a95695c988d8b">AF_STORAGE_CSR</a> format. </dd>
<dd>
The returned array is always dense. </dd>
<dd>
<code>optLhs</code> an only be one of <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421dab5052a3677cb5a64d91b16946cff1a75">AF_MAT_TRANS</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421da0d69e3f61f97ca65cdb8bc2ee5a21a03">AF_MAT_CTRANS</a>. </dd>
<dd>
<code>optRhs</code> can only be <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>. </dd></dl>

</div>
</div>
<a id="ga3d05bc14538f14713fe3ce65f6841f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d05bc14538f14713fe3ce65f6841f44">&#9670;&nbsp;</a></span>matmul() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain 2 matrix multiplications. </p>
<p>The matrix multiplications are done in a way to reduce temporary memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>out = a x b x c</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not supported in GFOR </dd></dl>

</div>
</div>
<a id="ga329f6ec3d910ca0443e4bc6b7cfe129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329f6ec3d910ca0443e4bc6b7cfe129f">&#9670;&nbsp;</a></span>matmul() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain 3 matrix multiplications. </p>
<p>The matrix multiplications are done in a way to reduce temporary memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The fourth array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>out = a x b x c x d</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not supported in GFOR </dd></dl>

</div>
</div>
<a id="ga63306b6ed967bd1055086db862fe885b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63306b6ed967bd1055086db862fe885b">&#9670;&nbsp;</a></span>matmul() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a>&#160;</td>
          <td class="paramname"><em>optLhs</em> = <code><a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a>&#160;</td>
          <td class="paramname"><em>optRhs</em> = <code><a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiply of two arrays. </p>
<p>Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p>Batched matrix multiplications are supported. Given below are the supported types of batch operations for any given set of two matrices A and B.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A </th><th class="markdownTableHeadCenter">Size of Input Matrix B </th><th class="markdownTableHeadCenter">Output Matrix Size  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, 1, 1 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
</table>
<p>where M, K, N are dimensions of the matrix and b2, b3 indicate batch size along the respective dimension.</p>
<p>For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The array object on the left hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The array object on the right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optLhs</td><td>Transpose left hand side before the function is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optRhs</td><td>Transpose right hand side before the function is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the matrix multiplication of lhs, rhs</dd></dl>
<dl class="section note"><dt>Note</dt><dd>optLhs and optRhs can only be one of <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421dab5052a3677cb5a64d91b16946cff1a75">AF_MAT_TRANS</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421da0d69e3f61f97ca65cdb8bc2ee5a21a03">AF_MAT_CTRANS</a> </dd>
<dd>
This function is not supported in GFOR</dd>
<dd>
<b> The following applies for Sparse-Dense matrix multiplication.</b> </dd>
<dd>
This function can be used with one sparse input. The sparse input must always be the <code>lhs</code> and the dense matrix must be <code>rhs</code>. </dd>
<dd>
The sparse array can only be of <a class="el" href="defines_8h.htm#a75e1422a62a43dc1ce727ccfb850600fa33553814922263702c5a95695c988d8b">AF_STORAGE_CSR</a> format. </dd>
<dd>
The returned array is always dense. </dd>
<dd>
<code>optLhs</code> an only be one of <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421dab5052a3677cb5a64d91b16946cff1a75">AF_MAT_TRANS</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421da0d69e3f61f97ca65cdb8bc2ee5a21a03">AF_MAT_CTRANS</a>. </dd>
<dd>
<code>optRhs</code> can only be <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="benchmarks_2blas_8cpp-example.htm#a1">benchmarks/blas.cpp</a>, <a class="el" href="benchmarks_2cg_8cpp-example.htm#a8">benchmarks/cg.cpp</a>, <a class="el" href="financial_2heston_model_8cpp-example.htm#a5">financial/heston_model.cpp</a>, <a class="el" href="getting_started_2convolve_8cpp-example.htm#a8">getting_started/convolve.cpp</a>, <a class="el" href="graphics_2gravity_sim_8cpp-example.htm#a17">graphics/gravity_sim.cpp</a>, <a class="el" href="lin_algebra_2svd_8cpp-example.htm#a5">lin_algebra/svd.cpp</a>, <a class="el" href="machine_learning_2deep_belief_net_8cpp-example.htm#a17">machine_learning/deep_belief_net.cpp</a>, <a class="el" href="machine_learning_2logistic_regression_8cpp-example.htm#a4">machine_learning/logistic_regression.cpp</a>, <a class="el" href="machine_learning_2neural_network_8cpp-example.htm#a10">machine_learning/neural_network.cpp</a>, <a class="el" href="machine_learning_2perceptron_8cpp-example.htm#a4">machine_learning/perceptron.cpp</a>, <a class="el" href="machine_learning_2rbm_8cpp-example.htm#a12">machine_learning/rbm.cpp</a>, and <a class="el" href="machine_learning_2softmax_regression_8cpp-example.htm#a4">machine_learning/softmax_regression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gadf90230a67ea7a0b4697511dd978b9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf90230a67ea7a0b4697511dd978b9c7">&#9670;&nbsp;</a></span>matmulNT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::matmulNT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiply of two arrays. </p>
<p>Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p>Batched matrix multiplications are supported. Given below are the supported types of batch operations for any given set of two matrices A and B.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A </th><th class="markdownTableHeadCenter">Size of Input Matrix B </th><th class="markdownTableHeadCenter">Output Matrix Size  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, 1, 1 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
</table>
<p>where M, K, N are dimensions of the matrix and b2, b3 indicate batch size along the respective dimension.</p>
<p>For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The array object on the left hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The array object on the right hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the matrix multiplication of <code>lhs</code>, transpose(<code>rhs</code>)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not supported in GFOR </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lin_algebra_2cholesky_8cpp-example.htm#a4">lin_algebra/cholesky.cpp</a>, <a class="el" href="machine_learning_2deep_belief_net_8cpp-example.htm#a16">machine_learning/deep_belief_net.cpp</a>, and <a class="el" href="machine_learning_2rbm_8cpp-example.htm#a11">machine_learning/rbm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga6655d7913b35d7e59f7c8560a5368fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6655d7913b35d7e59f7c8560a5368fbc">&#9670;&nbsp;</a></span>matmulTN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::matmulTN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiply of two arrays. </p>
<p>Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p>Batched matrix multiplications are supported. Given below are the supported types of batch operations for any given set of two matrices A and B.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A </th><th class="markdownTableHeadCenter">Size of Input Matrix B </th><th class="markdownTableHeadCenter">Output Matrix Size  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, 1, 1 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
</table>
<p>where M, K, N are dimensions of the matrix and b2, b3 indicate batch size along the respective dimension.</p>
<p>For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The array object on the left hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The array object on the right hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the matrix multiplication of transpose(<code>lhs</code>), <code>rhs</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not supported in GFOR </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="machine_learning_2deep_belief_net_8cpp-example.htm#a18">machine_learning/deep_belief_net.cpp</a>, <a class="el" href="machine_learning_2logistic_regression_8cpp-example.htm#a11">machine_learning/logistic_regression.cpp</a>, <a class="el" href="machine_learning_2perceptron_8cpp-example.htm#a8">machine_learning/perceptron.cpp</a>, <a class="el" href="machine_learning_2rbm_8cpp-example.htm#a16">machine_learning/rbm.cpp</a>, and <a class="el" href="machine_learning_2softmax_regression_8cpp-example.htm#a12">machine_learning/softmax_regression.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga7f3e5a6f282ea2c2c32886c95694bb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f3e5a6f282ea2c2c32886c95694bb88">&#9670;&nbsp;</a></span>matmulTT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::matmulTT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiply of two arrays. </p>
<p>Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p>Batched matrix multiplications are supported. Given below are the supported types of batch operations for any given set of two matrices A and B.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A </th><th class="markdownTableHeadCenter">Size of Input Matrix B </th><th class="markdownTableHeadCenter">Output Matrix Size  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, 1, 1 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \) </td><td class="markdownTableBodyCenter">\( \{ K, N, 1, 1 \} \) </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)  </td></tr>
</table>
<p>where M, K, N are dimensions of the matrix and b2, b3 indicate batch size along the respective dimension.</p>
<p>For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The array object on the left hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The array object on the right hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the matrix multiplication of transpose(<code>lhs</code>), transpose(<code>rhs</code>)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not supported in GFOR </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="machine_learning_2deep_belief_net_8cpp-example.htm#a21">machine_learning/deep_belief_net.cpp</a>, and <a class="el" href="machine_learning_2neural_network_8cpp-example.htm#a13">machine_learning/neural_network.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__data__func__constant_htm_gafc51b6a98765dd24cd4139f3bde00670"><div class="ttname"><a href="group__data__func__constant.htm#gafc51b6a98765dd24cd4139f3bde00670">af_constant</a></div><div class="ttdeci">AFAPI af_err af_constant(af_array *arr, const double val, const unsigned ndims, const dim_t *const dims, const af_dtype type)</div></div>
<div class="ttc" id="adefines_8h_htm_a7f026aa801b1fa6b85b0d992b414cccb"><div class="ttname"><a href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a></div><div class="ttdeci">long long dim_t</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00056">defines.h:56</a></div></div>
<div class="ttc" id="agroup__blas__func__matmul_htm_ga0463ae584163128718237b02faf5caf7"><div class="ttname"><a href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a></div><div class="ttdeci">AFAPI af_err af_gemm(af_array *C, const af_mat_prop opA, const af_mat_prop opB, const void *alpha, const af_array A, const af_array B, const void *beta)</div><div class="ttdoc">BLAS general matrix multiply (GEMM) of two af_array objects.</div></div>
<div class="ttc" id="adefines_8h_htm_a8e45f4aa3dbea6a7aa021dbc50a4a089"><div class="ttname"><a href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a></div><div class="ttdeci">void * af_array</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00240">defines.h:240</a></div></div>
<div class="ttc" id="aseq_8h_htm_a980be68ab878dfcd59377c9edd6cb22e"><div class="ttname"><a href="seq_8h.htm#a980be68ab878dfcd59377c9edd6cb22e">af_span</a></div><div class="ttdeci">static const af_seq af_span</div><div class="ttdef"><b>Definition:</b> <a href="seq_8h_source.htm#l00031">seq.h:31</a></div></div>
<div class="ttc" id="adefines_8h_htm_a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e"><div class="ttname"><a href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a></div><div class="ttdeci">@ AF_MAT_NONE</div><div class="ttdoc">Default.</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00349">defines.h:349</a></div></div>
<div class="ttc" id="adefines_8h_htm_a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b"><div class="ttname"><a href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a></div><div class="ttdeci">@ f32</div><div class="ttdoc">32-bit floating point values</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00211">defines.h:211</a></div></div>
<div class="ttc" id="astructaf__seq_htm"><div class="ttname"><a href="structaf__seq.htm">af_seq</a></div><div class="ttdoc">C-style struct to creating sequences for indexing.</div><div class="ttdef"><b>Definition:</b> <a href="seq_8h_source.htm#l00020">seq.h:20</a></div></div>
<div class="ttc" id="agroup__index__func__index_htm_ga4c9b9bd294a8210e8db72106705952a7"><div class="ttname"><a href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a></div><div class="ttdeci">AFAPI af_err af_index(af_array *out, const af_array in, const unsigned ndims, const af_seq *const index)</div><div class="ttdoc">Lookup the values of input array based on sequences.</div></div>
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-130950618-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
