<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130950618-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-130950618-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: matmul</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeInteractiveToc.init()
	DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="2" width="100%">
 <tbody>
  <tr id="projectrow">
  <td id="projectlogo"><a  href="index.htm"><img alt="Logo" src="arrayfire_logo.png"/></a></td>
  </tr>
  <tr id="projectrow">
  <td>
  <div id="projectbrief">A high-performance general-purpose compute library</div>
  </td>
  </tr>
  <!--END !PROJECT_NAME-->
  <div>
    <td id="gsearch">
        <script async src="https://cse.google.com/cse.js?cx=004356362924927882526:zup3ehe-7bs"></script>
        <div class="gcse-search"></div>
    </td>
  </div>
 </tr>
 <tr>
  <td>
    <div id="togglediv"></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li class="current"><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__blas__func__matmul.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">matmul<div class="ingroups"><a class="el" href="group__arrayfire__func.htm">ArrayFire Functions</a> &#124; <a class="el" href="group__func__categories.htm">ArrayFire Functions by Category</a> &raquo; <a class="el" href="group__linalg__mat.htm">Linear Algebra</a> &raquo; <a class="el" href="group__blas__mat.htm">BLAS operations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Matrix multiplication.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac061af289fcd39a07a3efba0f33fb17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#gac061af289fcd39a07a3efba0f33fb17f">matmul</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a> optLhs=<a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a> optRhs=<a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>)</td></tr>
<tr class="memdesc:gac061af289fcd39a07a3efba0f33fb17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface to multiply two matrices.  <a href="group__blas__func__matmul.htm#gac061af289fcd39a07a3efba0f33fb17f">More...</a><br /></td></tr>
<tr class="separator:gac061af289fcd39a07a3efba0f33fb17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf308bc06987aa90c6ef3f1435a8b00cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#gaf308bc06987aa90c6ef3f1435a8b00cd">matmulNT</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaf308bc06987aa90c6ef3f1435a8b00cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface to multiply two matrices.  <a href="group__blas__func__matmul.htm#gaf308bc06987aa90c6ef3f1435a8b00cd">More...</a><br /></td></tr>
<tr class="separator:gaf308bc06987aa90c6ef3f1435a8b00cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7a46a31434131ceb3d43a93ab0fba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#gaaf7a46a31434131ceb3d43a93ab0fba3">matmulTN</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaaf7a46a31434131ceb3d43a93ab0fba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface to multiply two matrices.  <a href="group__blas__func__matmul.htm#gaaf7a46a31434131ceb3d43a93ab0fba3">More...</a><br /></td></tr>
<tr class="separator:gaaf7a46a31434131ceb3d43a93ab0fba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga109ee835f4a634252336ef9a1dc4fa14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga109ee835f4a634252336ef9a1dc4fa14">matmulTT</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;lhs, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga109ee835f4a634252336ef9a1dc4fa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface to multiply two matrices.  <a href="group__blas__func__matmul.htm#ga109ee835f4a634252336ef9a1dc4fa14">More...</a><br /></td></tr>
<tr class="separator:ga109ee835f4a634252336ef9a1dc4fa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805419371b0fe290c18c05dea2744956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga805419371b0fe290c18c05dea2744956">matmul</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;a, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;b, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;c)</td></tr>
<tr class="memdesc:ga805419371b0fe290c18c05dea2744956"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface to chain multiply three matrices.  <a href="group__blas__func__matmul.htm#ga805419371b0fe290c18c05dea2744956">More...</a><br /></td></tr>
<tr class="separator:ga805419371b0fe290c18c05dea2744956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f94a05c94f9633647ed73120a7cbc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga10f94a05c94f9633647ed73120a7cbc3">matmul</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;a, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;b, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;c, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;d)</td></tr>
<tr class="memdesc:ga10f94a05c94f9633647ed73120a7cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface to chain multiply three matrices.  <a href="group__blas__func__matmul.htm#ga10f94a05c94f9633647ed73120a7cbc3">More...</a><br /></td></tr>
<tr class="separator:ga10f94a05c94f9633647ed73120a7cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0463ae584163128718237b02faf5caf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *C, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> opA, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> opB, const void *alpha, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> A, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> B, const void *beta)</td></tr>
<tr class="memdesc:ga0463ae584163128718237b02faf5caf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface to multiply two matrices.  <a href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">More...</a><br /></td></tr>
<tr class="separator:ga0463ae584163128718237b02faf5caf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3f29358b44286d19ff2037547649fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas__func__matmul.htm#ga3f3f29358b44286d19ff2037547649fe">af_matmul</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *out, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> lhs, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> rhs, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> optLhs, const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a> optRhs)</td></tr>
<tr class="memdesc:ga3f3f29358b44286d19ff2037547649fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface to multiply two matrices.  <a href="group__blas__func__matmul.htm#ga3f3f29358b44286d19ff2037547649fe">More...</a><br /></td></tr>
<tr class="separator:ga3f3f29358b44286d19ff2037547649fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Matrix multiplication. </p>
<p >Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p >Batched matrix multiplications are supported. The supported types of batch operations for any given set of two matrices A and B are given below,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A   </th><th class="markdownTableHeadCenter">Size of Input Matrix B   </th><th class="markdownTableHeadCenter">Output Matrix Size    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N,  1,  1 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)   </td></tr>
</table>
<p >where <code>M</code>, <code>K</code>, <code>N</code> are dimensions of the matrix and <code>b2</code>, <code>b3</code> indicate batch size along the respective dimension.</p>
<p >For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
 <h2 class="groupheader">Function Documentation</h2>
<a id="ga0463ae584163128718237b02faf5caf7" name="ga0463ae584163128718237b02faf5caf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0463ae584163128718237b02faf5caf7">&#9670;&#160;</a></span>af_gemm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>opA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>opB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface to multiply two matrices. </p>
<p >This provides an interface to the BLAS level 3 general matrix multiply (GEMM) of two <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> objects, which is generally defined as:</p>
<p class="formulaDsp">
\[
C = \alpha * opA(A)opB(B) + \beta * C
\]
</p>
<p >where \(\alpha\) (<code>alpha</code>) and \(\beta\) (<code>beta</code>) are both scalars; \(A\) and \(B\) are the matrix multiply operands; and \(opA\) and \(opB\) are noop (if <code>AF_MAT_NONE</code>) or transpose (if <code>AF_MAT_TRANS</code>) operations on \(A\) or \(B\) before the actual GEMM operation. Batched GEMM is supported if at least either \(A\) or \(B\) have more than two dimensions (see <a class="el" href="group__blas__func__matmul.htm#gac061af289fcd39a07a3efba0f33fb17f">af::matmul</a> for more details on broadcasting). However, only one <code>alpha</code> and one <code>beta</code> can be used for all of the batched matrix operands.</p>
<p >The <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> that <code>out</code> points to can be used both as an input and output. An allocation will be performed if you pass a null <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> handle (i.e. <code>af_array c = 0;</code>). If a valid <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> is passed as \(C\), the operation will be performed on that <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> itself. The C <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> must be the correct type and shape; otherwise, an error will be thrown.</p>
<dl class="section note"><dt>Note</dt><dd>Passing an af_array that has not been initialized to the C array is will cause undefined behavior.</dd></dl>
<p>This example demonstrates the usage of the af_gemm function on two matrices. The \(C\) <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> handle is initialized to zero here, so <a class="el" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a> will perform an allocation.</p>
<div class="fragment"><div class="line">    <a class="code hl_typedef" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> A, B;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> adims[] = {5, 3, 2};</div>
<div class="line">    <a class="code hl_typedef" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> bdims[] = {3, 5, 2};</div>
<div class="line">    <a class="code hl_function" href="group__data__func__constant.htm#gafc51b6a98765dd24cd4139f3bde00670">af_constant</a>(&amp;A, 1, 3, adims, <a class="code hl_enumvalue" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div>
<div class="line">    <a class="code hl_function" href="group__data__func__constant.htm#gafc51b6a98765dd24cd4139f3bde00670">af_constant</a>(&amp;B, 1, 3, bdims, <a class="code hl_enumvalue" href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> alpha = 1.f;</div>
<div class="line">    <span class="keywordtype">float</span> beta  = 0.f;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Undefined behavior!</span></div>
<div class="line">    <span class="comment">// af_array undef;</span></div>
<div class="line">    <span class="comment">// af_gemm(&amp;undef, AF_MAT_NONE, AF_MAT_NONE, &amp;alpha, a.get(), b.get(),</span></div>
<div class="line">    <span class="comment">// &amp;beta);</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> C = 0;</div>
<div class="line">    <a class="code hl_function" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a>(&amp;C, <a class="code hl_enumvalue" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="code hl_enumvalue" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, &amp;alpha, A, B, &amp;beta);</div>
<div class="line">    <span class="comment">// C =</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line"> </div>
<div class="ttc" id="adefines_8h_htm_a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b"><div class="ttname"><a href="defines_8h.htm#a023d8ac325fb14f1712a52fb0940b1d5a82ea90203678bdd0b547068f0a76524b">f32</a></div><div class="ttdeci">@ f32</div><div class="ttdoc">32-bit floating point values</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00211">defines.h:211</a></div></div>
<div class="ttc" id="adefines_8h_htm_a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e"><div class="ttname"><a href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a></div><div class="ttdeci">@ AF_MAT_NONE</div><div class="ttdoc">Default.</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00349">defines.h:349</a></div></div>
<div class="ttc" id="adefines_8h_htm_a7f026aa801b1fa6b85b0d992b414cccb"><div class="ttname"><a href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a></div><div class="ttdeci">long long dim_t</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00056">defines.h:56</a></div></div>
<div class="ttc" id="adefines_8h_htm_a8e45f4aa3dbea6a7aa021dbc50a4a089"><div class="ttname"><a href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a></div><div class="ttdeci">void * af_array</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00240">defines.h:240</a></div></div>
<div class="ttc" id="agroup__blas__func__matmul_htm_ga0463ae584163128718237b02faf5caf7"><div class="ttname"><a href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a></div><div class="ttdeci">AFAPI af_err af_gemm(af_array *C, const af_mat_prop opA, const af_mat_prop opB, const void *alpha, const af_array A, const af_array B, const void *beta)</div><div class="ttdoc">C Interface to multiply two matrices.</div></div>
<div class="ttc" id="agroup__data__func__constant_htm_gafc51b6a98765dd24cd4139f3bde00670"><div class="ttname"><a href="group__data__func__constant.htm#gafc51b6a98765dd24cd4139f3bde00670">af_constant</a></div><div class="ttdeci">AFAPI af_err af_constant(af_array *arr, const double val, const unsigned ndims, const dim_t *const dims, const af_dtype type)</div><div class="ttdoc">C Interface to generate an array with elements set to a specified value.</div></div>
</div><!-- fragment --><p >The following example shows how you can write to a previously allocated <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> using the <a class="el" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a> call. Here we are going to use the <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> s from the previous example and index into the first slice. Only the first slice of the original \(C\) af_array will be modified by this operation.</p>
<div class="fragment"><div class="line">    alpha                = 1.f;</div>
<div class="line">    beta                 = 1.f;</div>
<div class="line">    <a class="code hl_struct" href="structaf__seq.htm">af_seq</a> first_slice[] = {<a class="code hl_variable" href="seq_8h.htm#a980be68ab878dfcd59377c9edd6cb22e">af_span</a>, <a class="code hl_variable" href="seq_8h.htm#a980be68ab878dfcd59377c9edd6cb22e">af_span</a>, {0., 0., 1.}};</div>
<div class="line">    <a class="code hl_typedef" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> Asub, Bsub, Csub;</div>
<div class="line">    <a class="code hl_function" href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a>(&amp;Asub, A, 3, first_slice);</div>
<div class="line">    <a class="code hl_function" href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a>(&amp;Bsub, B, 3, first_slice);</div>
<div class="line">    <a class="code hl_function" href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a>(&amp;Csub, C, 3, first_slice);</div>
<div class="line">    <a class="code hl_function" href="group__blas__func__matmul.htm#ga0463ae584163128718237b02faf5caf7">af_gemm</a>(&amp;Csub, <a class="code hl_enumvalue" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="code hl_enumvalue" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, &amp;alpha, Asub, Bsub, &amp;beta);</div>
<div class="line">    <span class="comment">// C =</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//  6.   6.   6.   6.   6.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="line">    <span class="comment">//  3.   3.   3.   3.   3.</span></div>
<div class="ttc" id="agroup__index__func__index_htm_ga4c9b9bd294a8210e8db72106705952a7"><div class="ttname"><a href="group__index__func__index.htm#ga4c9b9bd294a8210e8db72106705952a7">af_index</a></div><div class="ttdeci">AFAPI af_err af_index(af_array *out, const af_array in, const unsigned ndims, const af_seq *const index)</div><div class="ttdoc">Lookup the values of input array based on sequences.</div></div>
<div class="ttc" id="aseq_8h_htm_a980be68ab878dfcd59377c9edd6cb22e"><div class="ttname"><a href="seq_8h.htm#a980be68ab878dfcd59377c9edd6cb22e">af_span</a></div><div class="ttdeci">static const af_seq af_span</div><div class="ttdef"><b>Definition:</b> <a href="seq_8h_source.htm#l00031">seq.h:31</a></div></div>
<div class="ttc" id="astructaf__seq_htm"><div class="ttname"><a href="structaf__seq.htm">af_seq</a></div><div class="ttdoc">C-style struct to creating sequences for indexing.</div><div class="ttdef"><b>Definition:</b> <a href="seq_8h_source.htm#l00020">seq.h:20</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td><code>A</code> * <code>B</code> = <code>C</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opA</td><td>operation to perform on A before the multiplication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opB</td><td>operation to perform on B before the multiplication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>alpha value; must be the same type as <code>A</code> and <code>B</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input array on the left-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>input array on the right-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>beta value; must be the same type as <code>A</code> and <code>B</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4fa2e56d1f9585788fed8fbe3a321bddd76">AF_SUCCESS</a>, if function returns successfully, else an <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> code is given </dd></dl>

</div>
</div>
<a id="ga3f3f29358b44286d19ff2037547649fe" name="ga3f3f29358b44286d19ff2037547649fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3f29358b44286d19ff2037547649fe">&#9670;&#160;</a></span>af_matmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_matmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>optLhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">af_mat_prop</a>&#160;</td>
          <td class="paramname"><em>optRhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface to multiply two matrices. </p>
<p >Performs matrix multiplication on two arrays.</p>
<dl class="section note"><dt>Note</dt><dd><b> The following applies for Sparse-Dense matrix multiplication.</b> </dd>
<dd>
This function can be used with one sparse input. The sparse input must always be the <code>lhs</code> and the dense matrix must be <code>rhs</code>. </dd>
<dd>
The sparse array can only be of <a class="el" href="defines_8h.htm#a75e1422a62a43dc1ce727ccfb850600fa33553814922263702c5a95695c988d8b">AF_STORAGE_CSR</a> format. </dd>
<dd>
The returned array is always dense. </dd>
<dd>
<code>optLhs</code> an only be one of <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421dab5052a3677cb5a64d91b16946cff1a75">AF_MAT_TRANS</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421da0d69e3f61f97ca65cdb8bc2ee5a21a03">AF_MAT_CTRANS</a>. </dd>
<dd>
<code>optRhs</code> can only be <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td><code>lhs</code> * <code>rhs</code> = <code>out</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>input array on the left-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>input array on the right-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optLhs</td><td>transpose <code>lhs</code> before the function is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optRhs</td><td>transpose <code>rhs</code> before the function is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4fa2e56d1f9585788fed8fbe3a321bddd76">AF_SUCCESS</a>, if function returns successfully, else an <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> code is given </dd></dl>

</div>
</div>
<a id="ga805419371b0fe290c18c05dea2744956" name="ga805419371b0fe290c18c05dea2744956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805419371b0fe290c18c05dea2744956">&#9670;&#160;</a></span>matmul() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface to chain multiply three matrices. </p>
<p >The matrix multiplications are done in a way to reduce temporary memory.</p>
<p >This function is not supported in GFOR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a x b x c </dd></dl>

</div>
</div>
<a id="ga10f94a05c94f9633647ed73120a7cbc3" name="ga10f94a05c94f9633647ed73120a7cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10f94a05c94f9633647ed73120a7cbc3">&#9670;&#160;</a></span>matmul() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface to chain multiply three matrices. </p>
<p >The matrix multiplications are done in a way to reduce temporary memory.</p>
<p >This function is not supported in GFOR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The fourth array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a x b x c x d </dd></dl>

</div>
</div>
<a id="gac061af289fcd39a07a3efba0f33fb17f" name="gac061af289fcd39a07a3efba0f33fb17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac061af289fcd39a07a3efba0f33fb17f">&#9670;&#160;</a></span>matmul() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a>&#160;</td>
          <td class="paramname"><em>optLhs</em> = <code><a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421d">matProp</a>&#160;</td>
          <td class="paramname"><em>optRhs</em> = <code><a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface to multiply two matrices. </p>
<p >Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p >Batched matrix multiplications are supported. The supported types of batch operations for any given set of two matrices A and B are given below,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A   </th><th class="markdownTableHeadCenter">Size of Input Matrix B   </th><th class="markdownTableHeadCenter">Output Matrix Size    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N,  1,  1 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)   </td></tr>
</table>
<p >where <code>M</code>, <code>K</code>, <code>N</code> are dimensions of the matrix and <code>b2</code>, <code>b3</code> indicate batch size along the respective dimension.</p>
<p >For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
 <p ><code>optLhs</code> and <code>optRhs</code> can only be one of <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421dab5052a3677cb5a64d91b16946cff1a75">AF_MAT_TRANS</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421da0d69e3f61f97ca65cdb8bc2ee5a21a03">AF_MAT_CTRANS</a>.</p>
<p >This function is not supported in GFOR.</p>
<dl class="section note"><dt>Note</dt><dd><b>The following applies for Sparse-Dense matrix multiplication.</b> </dd>
<dd>
This function can be used with one sparse input. The sparse input must always be the <code>lhs</code> and the dense matrix must be <code>rhs</code>. </dd>
<dd>
The sparse array can only be of <a class="el" href="defines_8h.htm#a75e1422a62a43dc1ce727ccfb850600fa33553814922263702c5a95695c988d8b">AF_STORAGE_CSR</a> format. </dd>
<dd>
The returned array is always dense. </dd>
<dd>
<code>optLhs</code> an only be one of <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421dab5052a3677cb5a64d91b16946cff1a75">AF_MAT_TRANS</a>, <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421da0d69e3f61f97ca65cdb8bc2ee5a21a03">AF_MAT_CTRANS</a>. </dd>
<dd>
<code>optRhs</code> can only be <a class="el" href="defines_8h.htm#a67fd2718ccb6233ec081fc7b4757421daccba98c5b50e203da4c452c2c00c3d3e">AF_MAT_NONE</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>input array on the left-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>input array on the right-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optLhs</td><td>transpose the left-hand side prior to multiplication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optRhs</td><td>transpose the right-hand side prior to multiplication </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> * <code>rhs</code> </dd></dl>

</div>
</div>
<a id="gaf308bc06987aa90c6ef3f1435a8b00cd" name="gaf308bc06987aa90c6ef3f1435a8b00cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf308bc06987aa90c6ef3f1435a8b00cd">&#9670;&#160;</a></span>matmulNT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> matmulNT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface to multiply two matrices. </p>
<p >The second matrix will be transposed.</p>
<p >Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p >Batched matrix multiplications are supported. The supported types of batch operations for any given set of two matrices A and B are given below,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A   </th><th class="markdownTableHeadCenter">Size of Input Matrix B   </th><th class="markdownTableHeadCenter">Output Matrix Size    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N,  1,  1 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)   </td></tr>
</table>
<p >where <code>M</code>, <code>K</code>, <code>N</code> are dimensions of the matrix and <code>b2</code>, <code>b3</code> indicate batch size along the respective dimension.</p>
<p >For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
 <p >This function is not supported in GFOR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>input array on the left-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>input array on the right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs</code> * transpose(<code>rhs</code>) </dd></dl>

</div>
</div>
<a id="gaaf7a46a31434131ceb3d43a93ab0fba3" name="gaaf7a46a31434131ceb3d43a93ab0fba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf7a46a31434131ceb3d43a93ab0fba3">&#9670;&#160;</a></span>matmulTN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> matmulTN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface to multiply two matrices. </p>
<p >The first matrix will be transposed.</p>
<p >Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p >Batched matrix multiplications are supported. The supported types of batch operations for any given set of two matrices A and B are given below,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A   </th><th class="markdownTableHeadCenter">Size of Input Matrix B   </th><th class="markdownTableHeadCenter">Output Matrix Size    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N,  1,  1 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)   </td></tr>
</table>
<p >where <code>M</code>, <code>K</code>, <code>N</code> are dimensions of the matrix and <code>b2</code>, <code>b3</code> indicate batch size along the respective dimension.</p>
<p >For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
 <p >This function is not supported in GFOR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>input array on the left-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>input array on the right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transpose(<code>lhs</code>) * <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ga109ee835f4a634252336ef9a1dc4fa14" name="ga109ee835f4a634252336ef9a1dc4fa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga109ee835f4a634252336ef9a1dc4fa14">&#9670;&#160;</a></span>matmulTT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> matmulTT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface to multiply two matrices. </p>
<p >Both matrices will be transposed.</p>
<p >Performs a matrix multiplication on the two input arrays after performing the operations specified in the options. The operations are done while reading the data from memory. This results in no additional memory being used for temporary buffers.</p>
<p >Batched matrix multiplications are supported. The supported types of batch operations for any given set of two matrices A and B are given below,</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Size of Input Matrix A   </th><th class="markdownTableHeadCenter">Size of Input Matrix B   </th><th class="markdownTableHeadCenter">Output Matrix Size    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N,  1,  1 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( \{ M, K,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( \{ M, K, b2, b3 \} \)   </td><td class="markdownTableBodyCenter">\( \{ K, N,  1,  1 \} \)   </td><td class="markdownTableBodyCenter">\( \{ M, N, b2, b3 \} \)   </td></tr>
</table>
<p >where <code>M</code>, <code>K</code>, <code>N</code> are dimensions of the matrix and <code>b2</code>, <code>b3</code> indicate batch size along the respective dimension.</p>
<p >For the last two entries in the above table, the 2D matrix is broadcasted to match the dimensions of 3D/4D array. This broadcast doesn't involve any additional memory allocations either on host or device.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse support was added to ArrayFire in v3.4.0. This function can be used for Sparse-Dense matrix multiplication. See the notes of the function for usage and restrictions.</dd></dl>
<hr  />
 <p >This function is not supported in GFOR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>input array on the left-hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>input array on the right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transpose(<code>lhs</code>) * transpose(<code>rhs</code>) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
        <li class="footer">Generated on Mon Sep 25 2023 12:35:30 for ArrayFire by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
    </ul>
</div>
</body>
</html>
