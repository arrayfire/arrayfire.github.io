<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130950618-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-130950618-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: Introduction to Vectorization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeInteractiveToc.init()
	DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="2" width="100%">
 <tbody>
  <tr id="projectrow">
  <td id="projectlogo"><a  href="index.htm"><img alt="Logo" src="arrayfire_logo.png"/></a></td>
  </tr>
  <tr id="projectrow">
  <td>
  <div id="projectbrief">A high-performance general-purpose compute library</div>
  </td>
  </tr>
  <!--END !PROJECT_NAME-->
  <div>
    <td id="gsearch">
        <script async src="https://cse.google.com/cse.js?cx=004356362924927882526:zup3ehe-7bs"></script>
        <div class="gcse-search"></div>
    </td>
  </div>
 </tr>
 <tr>
  <td>
    <div id="togglediv"></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('vectorization.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Introduction to Vectorization </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_C__Users_jmelonak_source_repos_arrayfire_arrayfire_docs_pages_vectorization"></a></p>
<p >Programmers and Data Scientists want to take advantage of fast and parallel computational devices. Writing vectorized code is necessary to get the best performance out of the current generation parallel hardware and scientific computing software. However, writing vectorized code may not be immediately intuitive. ArrayFire provides many ways to vectorize a given code segment. In this tutorial, we present several methods to vectorize code using ArrayFire and discuss the benefits and drawbacks associated with each method.</p>
<h1>Generic/Default vectorization</h1>
<p >By its very nature, ArrayFire is a vectorized library. Most functions operate on arrays as a whole &ndash; on all elements in parallel. Wherever possible, existing vectorized functions should be used opposed to manually indexing into arrays. For example consider the following code:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> a = <a class="code hl_function" href="group__data__func__range.htm#gaabed40660d2001b8d273d251cd4992c3">af::range</a>(10); <span class="comment">// [0,  9]</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; a.<a class="code hl_function" href="classaf_1_1array.htm#a10d14b019693bc98f672ad7c4ac60bac">dims</a>(0); ++i)</div>
<div class="line">{</div>
<div class="line">    a(i) = a(i) + 1;         <span class="comment">// [1, 10]</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassaf_1_1array_htm"><div class="ttname"><a href="classaf_1_1array.htm">af::array</a></div><div class="ttdoc">A multi dimensional data container.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.htm#l00037">array.h:37</a></div></div>
<div class="ttc" id="aclassaf_1_1array_htm_a10d14b019693bc98f672ad7c4ac60bac"><div class="ttname"><a href="classaf_1_1array.htm#a10d14b019693bc98f672ad7c4ac60bac">af::array::dims</a></div><div class="ttdeci">dim4 dims() const</div><div class="ttdoc">Get dimensions of the array.</div></div>
<div class="ttc" id="agroup__data__func__range_htm_gaabed40660d2001b8d273d251cd4992c3"><div class="ttname"><a href="group__data__func__range.htm#gaabed40660d2001b8d273d251cd4992c3">af::range</a></div><div class="ttdeci">AFAPI array range(const dim4 &amp;dims, const int seq_dim=-1, const dtype ty=f32)</div><div class="ttdoc">C++ Interface to generate an array with [0, n-1] values along the seq_dim dimension and tiled across ...</div></div>
</div><!-- fragment --><p >Although completely valid, the code is very inefficient as it results in a kernel kernels that operate on one datum. Instead, the developer should have used ArrayFire's overload of the + operator:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> a = <a class="code hl_function" href="group__data__func__range.htm#gaabed40660d2001b8d273d251cd4992c3">af::range</a>(10);  <span class="comment">// [0,  9]</span></div>
<div class="line">a = a + 1;                    <span class="comment">// [1, 10]</span></div>
</div><!-- fragment --><p >This code will result in a single kernel that operates on all 10 elements of <code>a</code> in parallel.</p>
<p >Most ArrayFire functions are vectorized. A small subset of these include:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator Category   </th><th class="markdownTableHeadNone">Functions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__arith__mat.htm">Arithmetic operations</a>   </td><td class="markdownTableBodyNone"><a class="el" href="group__arith__func__add.htm">+</a>, <a class="el" href="group__arith__func__sub.htm">-</a>, <a class="el" href="group__arith__func__mul.htm">*</a>, <a class="el" href="group__arith__func__div.htm">/</a>, <a class="el" href="group__arith__func__mod.htm">%</a>, <a class="el" href="group__arith__func__shiftr.htm">&gt;&gt;</a>, <a class="el" href="group__arith__func__shiftl.htm">&lt;&lt;</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__logic__mat.htm">Logical operations</a>   </td><td class="markdownTableBodyNone"><a class="el" href="group__arith__func__and.htm">&amp;&amp;</a>, ||<a class="el" href="group__arith__func__or.htm">(or)</a>, <a class="el" href="group__arith__func__lt.htm">&lt;</a>, <a class="el" href="group__arith__func__gt.htm">&gt;</a>, <a class="el" href="group__arith__func__eq.htm">==</a>, <a class="el" href="group__arith__func__neq.htm">!=</a> etc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__numeric__mat.htm">Numeric functions</a>   </td><td class="markdownTableBodyNone">abs(), floor(), round(), min(), max(), etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__complex__mat.htm">Complex operations</a>   </td><td class="markdownTableBodyNone">real(), imag(), conj(), etc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__explog__mat.htm">Exponential and logarithmic functions</a>   </td><td class="markdownTableBodyNone">exp(), log(), expm1(), log1p(), etc.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__trig__mat.htm">Trigonometric functions</a>   </td><td class="markdownTableBodyNone">sin(), cos(), tan(), etc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__hyper__mat.htm">Hyperbolic functions</a>   </td><td class="markdownTableBodyNone">sinh(), cosh(), tanh(), etc.   </td></tr>
</table>
<p >In addition to element-wise operations, many other functions are also vectorized in ArrayFire.</p>
<p >Notice that even that perform some form of aggregation (e.g. <code>sum()</code> or <code>min()</code>), signal processing (like <code>convolve()</code>), and even image processing functions (i.e. <code>rotate()</code>) all support vectorization on different columns or images. For example, if we have <code>NUM</code> images of size <code>WIDTH</code> by <code>HEIGHT</code>, one could convolve each image in a vector fashion as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> g_coef[] = { 1, 2, 1,</div>
<div class="line">                   2, 4, 2,</div>
<div class="line">                   1, 2, 1 };</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filter = 1.f/16 * <a class="code hl_class" href="classaf_1_1array.htm">af::array</a>(3, 3, g_coef);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> signal = randu(WIDTH, HEIGHT, NUM);</div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> conv = convolve2(signal, filter);</div>
</div><!-- fragment --><p >Similarly, one can rotate 100 images by 45 degrees in a single call using code like the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Construct an array of 100 WIDTH x HEIGHT images of random numbers</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> imgs = randu(WIDTH, HEIGHT, 100);</div>
<div class="line"><span class="comment">// Rotate all of the images in a single command</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> rot_imgs = rotate(imgs, 45);</div>
</div><!-- fragment --><p >Although <em>most</em> functions in ArrayFire do support vectorization, some do not. Most notably, all linear algebra functions. Even though they are not vectorized linear algebra operations still execute in parallel on your hardware.</p>
<p >Using the built in vectorized operations should be the first and preferred method of vectorizing any code written with ArrayFire.</p>
<h1>GFOR: Parallel for-loops</h1>
<p >Another novel method of vectorization present in ArrayFire is the GFOR loop replacement construct. GFOR allows launching all iterations of a loop in parallel on the GPU or device, as long as the iterations are independent. While the standard for-loop performs each iteration sequentially, ArrayFire's gfor-loop performs each iteration at the same time (in parallel). ArrayFire does this by tiling out the values of all loop iterations and then performing computation on those tiles in one pass. You can think of gfor as performing auto-vectorization of your code, e.g. you write a gfor-loop that increments every element of a vector but behind the scenes ArrayFire rewrites it to operate on the entire vector in parallel.</p>
<p >The original for-loop example at the beginning of this document could be rewritten using GFOR as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> a = <a class="code hl_function" href="group__data__func__range.htm#gaabed40660d2001b8d273d251cd4992c3">af::range</a>(10);</div>
<div class="line"><a class="code hl_define" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a>(seq i, n)</div>
<div class="line">    a(i) = a(i) + 1;</div>
<div class="ttc" id="agfor_8h_htm_a6d6cd11d53daad217fd0b92f5a7ceec6"><div class="ttname"><a href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a></div><div class="ttdeci">#define gfor(var,...)</div><div class="ttdef"><b>Definition:</b> <a href="gfor_8h_source.htm#l00026">gfor.h:26</a></div></div>
</div><!-- fragment --><p >In this case, each instance of the gfor loop is independent, thus ArrayFire will automatically tile out the <code>a</code> array in device memory and execute the increment kernels in parallel.</p>
<p >To see another example, you could run an accum() on every slice of a matrix in a for-loop, or you could "vectorize" and simply do it all in one gfor-loop operation:</p>
<div class="fragment"><div class="line"><span class="comment">// runs each accum() in sequence</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i)</div>
<div class="line">   B(span,i) = accum(A(span,i));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// runs N accums in parallel</span></div>
<div class="line"><a class="code hl_define" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a> (seq i, N)</div>
<div class="line">   B(span,i) = accum(A(span,i));</div>
</div><!-- fragment --><p >However, returning to our previous vectorization technique, accum() is already vectorized and the operation could be completely replaced with merely:</p>
<div class="fragment"><div class="line">B = accum(A);</div>
</div><!-- fragment --><p >It is best to vectorize computation as much as possible to avoid the overhead in both for-loops and gfor-loops. However, the gfor-loop construct is most effective in the narrow case of broadcast-style operations. Consider the case when we have a vector of constants that we wish to apply to a collection of variables, such as expressing the values of a linear combination for multiple vectors. The broadcast of one set of constants to many vectors works well with gfor-loops:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> p=4, n=1000;</div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> consts = <a class="code hl_function" href="group__random__func__randu.htm#ga828798e84ab467f6f8568830f1c853f3">af::randu</a>(p);</div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> var_terms = randn(p, n);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a>(seq i, n)</div>
<div class="line">    combination(span, i) = consts * var_terms(span, i);</div>
<div class="ttc" id="agroup__random__func__randu_htm_ga828798e84ab467f6f8568830f1c853f3"><div class="ttname"><a href="group__random__func__randu.htm#ga828798e84ab467f6f8568830f1c853f3">af::randu</a></div><div class="ttdeci">AFAPI array randu(const dim4 &amp;dims, const dtype ty, randomEngine &amp;r)</div><div class="ttdoc">C++ Interface to create an array of random numbers uniformly distributed.</div></div>
</div><!-- fragment --><p >Using GFOR requires following several rules and multiple guidelines for optimal performance. The details of this vectorization method can be found in the <a class="el" href="page_gfor.htm#gfor">GFOR documentation</a>.</p>
<h1>Batching</h1>
<p >The batchFunc() function allows the broad application of existing ArrayFire functions to multiple sets of data. Effectively, batchFunc() allows ArrayFire functions to execute in "batch processing" mode. In this mode, functions will find a dimension which contains "batches" of data to be processed and will parallelize the procedure.</p>
<p >Consider the following example. Here we create a filter which we would like to apply to each of the weight vectors. The naive solution would be using a for-loop as we have seen previously:</p>
<div class="fragment"><div class="line"><span class="comment">// Create the filter and the weight vectors</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filter = randn(1, 5);</div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> weights = randu(5, 5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply the filter using a for-loop</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filtered_weights = constant(0, 5, 5);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;weights.<a class="code hl_function" href="classaf_1_1array.htm#a10d14b019693bc98f672ad7c4ac60bac">dims</a>(1); ++i){</div>
<div class="line">    filtered_weights.<a class="code hl_function" href="group__array__mem__col.htm#gae54ff0116727d4f4f5f91306c609704e">col</a>(i) = filter * weights.<a class="code hl_function" href="group__array__mem__col.htm#gae54ff0116727d4f4f5f91306c609704e">col</a>(i);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__array__mem__col_htm_gae54ff0116727d4f4f5f91306c609704e"><div class="ttname"><a href="group__array__mem__col.htm#gae54ff0116727d4f4f5f91306c609704e">af::array::col</a></div><div class="ttdeci">array::array_proxy col(int index)</div><div class="ttdoc">Returns a reference to a col.</div></div>
</div><!-- fragment --><p >However, as we have discussed above, this solution will be very inefficient. One may be tempted to implement a vectorized solution as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// Create the filter and the weight vectors</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filter = randn(1, 5);</div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> weights = randu(5, 5);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filtered_weights = filter * weights; <span class="comment">// fails due to dimension mismatch</span></div>
</div><!-- fragment --><p >However, the dimensions of <code>filter</code> and <code>weights</code> do not match, thus ArrayFire will generate a runtime error.</p>
<p ><code>batchfunc()</code> was created to solve this specific problem. The signature of the function is as follows:</p>
<div class="fragment"><div class="line">array batchFunc(<span class="keyword">const</span> array &amp;lhs, <span class="keyword">const</span> array &amp;rhs, batchFunc_t func);</div>
</div><!-- fragment --><p >where <code>__batchFunc_t__</code> is a function pointer of the form:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> array (*batchFunc_t) (<span class="keyword">const</span> array &amp;lhs, <span class="keyword">const</span> array &amp;rhs);</div>
</div><!-- fragment --><p >So, to use batchFunc(), we need to provide the function we wish to apply as a batch operation. For illustration's sake, let's "implement" a multiplication function following the format.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> my_mult (<span class="keyword">const</span> <a class="code hl_class" href="classaf_1_1array.htm">af::array</a> &amp;lhs, <span class="keyword">const</span> <a class="code hl_class" href="classaf_1_1array.htm">af::array</a> &amp;rhs){</div>
<div class="line">    <span class="keywordflow">return</span> lhs * rhs;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Our final batch call is not much more difficult than the ideal syntax we imagined.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the filter and the weight vectors</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filter = randn(1, 5);</div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> weights = randu(5, 5);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Apply the batch function</span></div>
<div class="line"><a class="code hl_class" href="classaf_1_1array.htm">af::array</a> filtered_weights = batchFunc( filter, weights, my_mult );</div>
</div><!-- fragment --><p >The batch function will work with many previously mentioned vectorized ArrayFire functions. It can even work with a combination of those functions if they are wrapped inside a helper function matching the <code>__batchFunc_t__</code> signature. One limitation of <code>batchfunc()</code> is that it cannot be used from within a <code><a class="el" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor()</a></code> loop at the present time.</p>
<h1>Advanced Vectorization</h1>
<p >We have seen the different methods ArrayFire provides to vectorize our code. Tying them all together is a slightly more involved process that needs to consider data dimensionality and layout, memory usage, nesting order, etc. An excellent example and discussion of these factors can be found on our blog:</p>
<p ><a href="http://arrayfire.com/how-to-write-vectorized-code/">http://arrayfire.com/how-to-write-vectorized-code/</a></p>
<p >It's worth noting that the content discussed in the blog has since been transformed into a convenient <a class="el" href="group__cv__func__nearest__neighbour.htm#ga9973d0dd5241f71c2fafb9ebd5095d78" title="C++ interface wrapper for determining the nearest neighbouring points to a given set of points.">af::nearestNeighbour()</a> function. Before writing something from scratch, check that ArrayFire doesn't already have an implementation. The default vectorized nature of ArrayFire and an extensive collection of functions will speed things up in addition to replacing dozens of lines of code! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
        <li class="footer">Generated on Wed Aug 30 2023 15:41:55 for ArrayFire by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
    </ul>
</div>
</body>
</html>
