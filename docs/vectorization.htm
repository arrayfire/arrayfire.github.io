<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Introduction to Vectorization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="afw.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/>
  </td>
	 <td id="gsearch">
   <div><script>
	    (function() {
        var cx = '004356362924927882526:zup3ehe-7bs';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
	    var s = document.getElementsByTagName('script')[0];
	    s.parentNode.insertBefore(gcse, s);
	  })();
  </script>
  <gcse:search></gcse:search>
</div>
	 </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.htm"><span>Tutorials</span></a></li>
      <li><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vectorization.htm','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Introduction to Vectorization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Programmers and Data Scientists want to take advantage of fast and parallel computational devices. Writing vectorized code is becoming a necessity to get the best performance out of the current generation parallel hardware and scientific computing software. However, writing vectorized code may not be intuitive immediately. Arrayfire provides many ways to vectorize a given code segment. In this tutorial, we will be presenting various ways to vectorize code using ArrayFire and the benefits and drawbacks associated with each method.</p>
<h1>Generic/Default vectorization</h1>
<p>By its very nature, Arrayfire is a vectorized library. Most functions operate on arrays as a whole &ndash; on all elements in parallel. Wherever possible, existing vectorized functions should be used opposed to manually indexing into arrays. For example, consider this valid, yet mislead code that attempts to increment each element of an array:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> a = <a class="code" href="group__data__func__range.htm#ga3789475e962b4c31e07c1c3bdab8498b">af::range</a>(10); <span class="comment">// [0,  9]</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; a.<a class="code" href="group__method__mat.htm#gaf056729e3ff924f5c1d41e0a8db3ce1b">dims</a>(0); ++i)</div>
<div class="line">{</div>
<div class="line">    a(i) = a(i) + 1;         <span class="comment">// [1, 10]</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Instead, the existing vectorized Arrayfire overload of the + operator should have been used:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> a = <a class="code" href="group__data__func__range.htm#ga3789475e962b4c31e07c1c3bdab8498b">af::range</a>(10);  <span class="comment">// [0,  9]</span></div>
<div class="line">a = a + 1;                    <span class="comment">// [1, 10]</span></div>
</div><!-- fragment --><p>Most Arrayfire functions are vectorized. A small subset of these include:</p>
<table class="doxtable">
<tr>
<th>Operator Category </th><th>Functions  </th></tr>
<tr>
<td><a class="el" href="group__arith__mat.htm">Arithmetic operations</a> </td><td><a class="el" href="group__arith__func__add.htm">+</a>, <a class="el" href="group__arith__func__sub.htm">-</a>, <a class="el" href="group__arith__func__mul.htm">*</a>, <a class="el" href="group__arith__func__div.htm">/</a>, <a class="el" href="group__arith__func__mod.htm">%</a>, <a class="el" href="group__arith__func__shiftr.htm">&gt;&gt;</a>, <a class="el" href="group__arith__func__shiftl.htm">&lt;&lt;</a> </td></tr>
<tr>
<td><a class="el" href="group__complex__mat.htm">Complex operations</a> </td><td><a class="el" href="group__arith__func__real.htm#ga09209f0d8ffd557608fef6bade1689c9" title="C++ Interface for getting real part from complex array. ">real()</a>, <a class="el" href="group__arith__func__imag.htm#gade4b0cbdc402bc05d45a7f130b1fa865" title="C++ Interface for getting imaginary part from complex array. ">imag()</a>, <a class="el" href="namespaceaf.htm#aee503b023cfbcf64eb2d230b7c24c280">conj()</a>, etc. </td></tr>
<tr>
<td><a class="el" href="group__explog__mat.htm">Exponential and logarithmic functions</a> </td><td><a class="el" href="group__arith__func__exp.htm#ga9ddbaf0852fbf988400b9677705b2a00" title="C++ Interface for exponential of an array. ">exp()</a>, <a class="el" href="group__arith__func__log.htm#gaf15f1af67e62541e0322f4c94acd0293" title="C++ Interface for natural logarithm. ">log()</a>, <a class="el" href="group__arith__func__expm1.htm#gae085a00e6da69ca27ecc660552ab61f9" title="C++ Interface for exponential of an array minus 1. ">expm1()</a>, <a class="el" href="group__arith__func__log1p.htm#ga047f56ac38021fd5bfd6d91ff1efb268" title="C++ Interface for natural logarithm of 1 + input. ">log1p()</a>, etc. </td></tr>
<tr>
<td><a class="el" href="group__hyper__mat.htm">Hyperbolic functions</a> </td><td><a class="el" href="group__arith__func__sinh.htm#ga42ad4a8882b5259db99b1498742fc9b8" title="C++ Interface for sinh. ">sinh()</a>, <a class="el" href="group__arith__func__cosh.htm#ga84729d7c30446d8d4970b067ee67dd3c" title="C++ Interface for cosh. ">cosh()</a>, <a class="el" href="group__arith__func__tanh.htm#ga269ab0934aa1ae4157b37c52ab555966" title="C++ Interface for tanh. ">tanh()</a>, etc. </td></tr>
<tr>
<td><a class="el" href="group__logic__mat.htm">Logical operations</a> </td><td><a class="el" href="group__arith__func__and.htm">&amp;&amp;</a>, ||<a class="el" href="group__arith__func__or.htm">(or)</a>, <a class="el" href="group__arith__func__lt.htm">&lt;</a>, <a class="el" href="group__arith__func__gt.htm">&gt;</a>, <a class="el" href="group__arith__func__eq.htm">==</a>, <a class="el" href="group__arith__func__neq.htm">!=</a> etc. </td></tr>
<tr>
<td><a class="el" href="group__numeric__mat.htm">Numeric functions</a> </td><td><a class="el" href="group__arith__func__abs.htm#ga23aa8c28a5ffa9368cc92abb143f5eaa" title="C++ Interface for absolute value. ">abs()</a>, <a class="el" href="group__arith__func__floor.htm#ga3e75b4b34f55a6ce68cfa762eff995a6" title="C++ Interface for flooring an array of numbers. ">floor()</a>, <a class="el" href="group__arith__func__round.htm#gafefce014e11cc4b3c3af64a73b28a76b" title="C++ Interface for rounding an array of numbers. ">round()</a>, <a class="el" href="group__reduce__func__min.htm#ga2b1287d1babb569d28bc6ee1c8e8e1ea" title="C++ Interface for minimum values in an array. ">min()</a>, <a class="el" href="group__reduce__func__max.htm#ga4459daf5a3b081fb4ee15eb49d8c902a" title="C++ Interface for maximum values in an array. ">max()</a>, etc. </td></tr>
<tr>
<td><a class="el" href="group__trig__mat.htm">Trigonometric functions</a> </td><td><a class="el" href="group__arith__func__sin.htm#gac6fdb44f59fbbffdc55c9c4af29e08f4" title="C++ Interface for sin. ">sin()</a>, <a class="el" href="group__arith__func__cos.htm#ga00be564e1f588df68288d2dec8578cb6" title="C++ Interface for cos. ">cos()</a>, <a class="el" href="group__arith__func__tan.htm#ga5444749c3b32afa8097eab85634053ff" title="C++ Interface for tan. ">tan()</a>, etc. </td></tr>
</table>
<p>In addition to element-wise operations, many other functions are also vectorized in Arrayfire.</p>
<p>Vector operations such as <a class="el" href="group__reduce__func__min.htm#ga2b1287d1babb569d28bc6ee1c8e8e1ea" title="C++ Interface for minimum values in an array. ">min()</a> support vectorization:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> arr = <a class="code" href="group__data__func__randn.htm#gae8aa1f5ec310aeb9e4cbd19d63998349">randn</a>(100);</div>
<div class="line">std::cout &lt;&lt; min&lt;float&gt;(arr) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Signal processing functions like <a class="el" href="group__signal__func__convolve.htm#gae79b64c8b0d6a06309e8b67bf89cf6c9" title="C++ Interface for convolution any(one through three) dimensional signals. ">convolve()</a> support vectorization:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> g_coef[] = { 1, 2, 1,</div>
<div class="line">                   2, 4, 2,</div>
<div class="line">                   1, 2, 1 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> <a class="code" href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">filter</a> = 1.f/16 * <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">af::array</a>(3, 3, f_coef);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> signal = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(WIDTH, HEIGHT, NUM);</div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> conv = <a class="code" href="group__signal__func__convolve2.htm#ga0aec29b4d4c9cf4412420b91c96ffe6c">convolve2</a>(signal, filter);</div>
</div><!-- fragment --><p>Image processing functions such as <a class="el" href="group__transform__func__rotate.htm#ga6555d91c01571c362ebd3bace76d21ea" title="C++ Interface for rotating an image. ">rotate()</a> support vectorization:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> imgs = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(WIDTH, HEIGHT, 100); <span class="comment">// 100 (WIDTH x HEIGHT) images</span></div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> rot_imgs = <a class="code" href="group__transform__func__rotate.htm#ga6555d91c01571c362ebd3bace76d21ea">rotate</a>(imgs, 45); <span class="comment">// 100 rotated images</span></div>
</div><!-- fragment --><p>One class of functions that does not support vectorization is the set of linear algebra functions. Using the built in vectorized operations should be the first and preferred method of vectorizing any code written with Arrayfire.</p>
<h1>GFOR: Parallel for-loops</h1>
<p>Another novel method of vectorization present in Arrayfire is the GFOR loop replacement construct. GFOR allows launching all iterations of a loop in parallel on the GPU or device, as long as the iterations are independent. While the standard for-loop performs each iteration sequentially, ArrayFire's gfor-loop performs each iteration at the same time (in parallel). ArrayFire does this by tiling out the values of all loop iterations and then performing computation on those tiles in one pass. You can think of gfor as performing auto-vectorization of your code, e.g. you write a gfor-loop that increments every element of a vector but behind the scenes ArrayFire rewrites it to operate on the entire vector in parallel.</p>
<p>We can remedy our first example with GFOR:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> a = <a class="code" href="group__data__func__range.htm#ga3789475e962b4c31e07c1c3bdab8498b">af::range</a>(10);</div>
<div class="line"><a class="code" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a>(seq i, n)</div>
<div class="line">    a(i) = a(i) + 1;</div>
</div><!-- fragment --><p>To see another example, you could run an <a class="el" href="group__scan__func__accum.htm#gae450135c4ae1bdaa4489804a215f3214" title="C++ Interface exclusive sum (cumulative sum) of an array. ">accum()</a> on every slice of a matrix in a for-loop, or you could "vectorize" and simply do it all in one gfor-loop operation:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i)</div>
<div class="line">   B(span,i) = <a class="code" href="group__scan__func__accum.htm#gae450135c4ae1bdaa4489804a215f3214">accum</a>(A(span,i)); <span class="comment">// runs each accum() in sequence</span></div>
<div class="line"><a class="code" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a> (seq i, N)</div>
<div class="line">   B(span,i) = <a class="code" href="group__scan__func__accum.htm#gae450135c4ae1bdaa4489804a215f3214">accum</a>(A(span,i)); <span class="comment">// runs N accums in parallel</span></div>
</div><!-- fragment --><p>However, returning to our previous vectorization technique, <a class="el" href="group__scan__func__accum.htm#gae450135c4ae1bdaa4489804a215f3214" title="C++ Interface exclusive sum (cumulative sum) of an array. ">accum()</a> is already vectorized and the operation could be completely replaced with merely:</p>
<div class="fragment"><div class="line">B = <a class="code" href="group__scan__func__accum.htm#gae450135c4ae1bdaa4489804a215f3214">accum</a>(A);</div>
</div><!-- fragment --><p>It is best to vectorize computation as much as possible to avoid the overhead in both for-loops and gfor-loops. However, the gfor-loop construct is most effective in the narrow case of broadcast-style operations. Consider the case when we have a vector of constants that we wish to apply to a collection of variables, such as expressing the values of a linear combination for multiple vectors. The broadcast of one set of constants to many vectors works well with gfor-loops:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> p=4, n=1000;</div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> consts = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">af::randu</a>(p);</div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> var_terms = <a class="code" href="group__data__func__randn.htm#gae8aa1f5ec310aeb9e4cbd19d63998349">randn</a>(p, n);</div>
<div class="line"></div>
<div class="line"><a class="code" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor</a>(seq i, n)</div>
<div class="line">    combination(span, i) = consts * var_terms(span, i);</div>
</div><!-- fragment --><p>Using GFOR requires following several rules and multiple guidelines for optimal performance. The details of this vectorization method can be found in the <a class="el" href="page_gfor.htm#gfor">GFOR documentation</a>.</p>
<h1>Batching</h1>
<p>The <a class="el" href="namespaceaf.htm#aa0eb9e160f5be4b95234543e5c47934b">batchFunc()</a> function allows the broad application of existing Arrayfire functions to multiple sets of data. Effectively, <a class="el" href="namespaceaf.htm#aa0eb9e160f5be4b95234543e5c47934b">batchFunc()</a> allows Arrayfire functions to execute in "batch processing" mode. In this mode, functions will find a dimension which contains "batches" of data to be processed and will parallelize the procedure.</p>
<p>Consider the following example:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> filter = <a class="code" href="group__data__func__randn.htm#gae8aa1f5ec310aeb9e4cbd19d63998349">randn</a>(1, 5);</div>
<div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> weights = <a class="code" href="group__data__func__randu.htm#ga15a5110a447509cab9589b2ad56c5e55">randu</a>(5, 5);</div>
</div><!-- fragment --><p>We have a filter that we would like to apply to each of several weights vectors. The naive solution would be using a loop as we've seen before:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> filtered_weights = <a class="code" href="group__data__func__constant.htm#ga3c58da8ca31ae6c871379aeb587b8b0d">constant</a>(0, 5, 5);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;weights.<a class="code" href="group__method__mat.htm#gaf056729e3ff924f5c1d41e0a8db3ce1b">dims</a>(1); ++i){</div>
<div class="line">    filtered_weights.<a class="code" href="group__array__mem__col.htm#gae54ff0116727d4f4f5f91306c609704e">col</a>(i) = filter * weights.<a class="code" href="group__array__mem__col.htm#gae54ff0116727d4f4f5f91306c609704e">col</a>(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However we would like a vectorized solution. The following syntax begs to be used:</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> filtered_weights = filter * weights; <span class="comment">// fails due to dimension mismatch</span></div>
</div><!-- fragment --><p>This fails due to the (5x1), (5x5) dimension mismatch. Wouldn't it be nice if Arrayfire could figure out along which dimension we intend to apply the batch operation? That is exactly what <a class="el" href="namespaceaf.htm#aa0eb9e160f5be4b95234543e5c47934b">batchFunc()</a> does! The signature of the function is:</p>
<p><code>array batchFunc(const array &amp;lhs, const array &amp;rhs, batchFunc_t func);</code></p>
<p>where <b>batchFunc_t</b> is a function pointer of the form: <code>typedef array (*batchFunc_t) (const array &amp;lhs, const array &amp;rhs);</code></p>
<p>So, to use <a class="el" href="namespaceaf.htm#aa0eb9e160f5be4b95234543e5c47934b">batchFunc()</a>, we need to provide the function we will be applying as a batch operation. For illustration's sake, let's "implement" a multiplication function following the format.</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> my_mult (<span class="keyword">const</span> <a class="code" href="classaf_1_1array.htm">af::array</a> &amp;lhs, <span class="keyword">const</span> <a class="code" href="classaf_1_1array.htm">af::array</a> &amp;rhs){</div>
<div class="line">    <span class="keywordflow">return</span> lhs * rhs;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our final batch call is not much more difficult than the ideal syntax we imagined.</p>
<div class="fragment"><div class="line"><a class="code" href="classaf_1_1array.htm">af::array</a> filtered_weights = <a class="code" href="namespaceaf.htm#aa0eb9e160f5be4b95234543e5c47934b">batchFunc</a>( filter, weights, my_mult );</div>
</div><!-- fragment --><p>The batch function will work with many previously mentioned vectorized Arrayfire functions. It can even work with a combination of those functions if they are wrapped inside a helper function matching the <b>batchFunc_t</b> signature. Unfortunately, the batch function cannot be used within a <a class="el" href="gfor_8h.htm#a6d6cd11d53daad217fd0b92f5a7ceec6">gfor()</a> construct at this moment.</p>
<h1>Advanced Vectorization</h1>
<p>We have seen the different methods Arrayfire provides to vectorize our code. Tying them all together is a slightly more involved process that needs to consider data dimensionality and layout, memory usage, nesting order, etc. An excellent example and discussion of these factors can be found on our blog:</p>
<p><a href="http://arrayfire.com/how-to-write-vectorized-code/">http://arrayfire.com/how-to-write-vectorized-code/</a></p>
<p>It's worth noting that the content discussed in the blog has since been transformed into a convenient <a class="el" href="group__cv__func__nearest__neighbour.htm#ga8839ead81cbcd6b433822205713bfe79" title="C++ Interface wrapper for Nearest Neighbour. ">af::nearestNeighbour()</a> function. Before writing something from scratch, check that Arrayfire doesn't already have an implementation. The default vectorized nature of Arrayfire and an extensive collection of functions will speed things up in addition to replacing dozens of lines of code! </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5076919-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
