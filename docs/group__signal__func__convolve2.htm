<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArrayFire: convolve2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="arrayfire.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="arrayfire_logo.png"/></td>
   <td id="gsearch">
       <div><script>
             (function() {
                 var cx = '004356362924927882526:zup3ehe-7bs';
                 var gcse = document.createElement('script');
                 gcse.type = 'text/javascript';
                 gcse.async = true;
                 gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                            '//www.google.com/cse/cse.js?cx=' + cx;
                 var s = document.getElementsByTagName('script')[0];
                 s.parentNode.insertBefore(gcse, s);
             })();
       </script>
       <gcse:search></gcse:search>
       <div>
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorials.htm"><span>Tutorials</span></a></li>
      <li class="current"><a href="modules.htm"><span>Functions</span></a></li>
      <li><a href="releasenotes.htm"><span>Release&#160;Notes</span></a></li>
      <li><a href="examples.htm"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__signal__func__convolve2.htm',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">convolve2<div class="ingroups"><a class="el" href="group__arrayfire__func.htm">ArrayFire Functions</a><a class="el" href="group__func__categories.htm">ArrayFire Functions by Category</a> &raquo; <a class="el" href="group__signal__mat.htm">Signal Processing</a> &raquo;  &#124; <a class="el" href="group__convolve__mat.htm">Convolutions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Convolution Integral for two dimensional data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0aec29b4d4c9cf4412420b91c96ffe6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal__func__convolve2.htm#ga0aec29b4d4c9cf4412420b91c96ffe6c">convolve2</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;signal, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;<a class="el" href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">filter</a>, const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">convMode</a> mode=<a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a>, const <a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3db">convDomain</a> domain=<a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3dbae105d11695ba3a2287e32c552d3567dd">AF_CONV_AUTO</a>)</td></tr>
<tr class="memdesc:ga0aec29b4d4c9cf4412420b91c96ffe6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface for convolution on two dimensional signals.  <a href="group__signal__func__convolve2.htm#ga0aec29b4d4c9cf4412420b91c96ffe6c">More...</a><br /></td></tr>
<tr class="separator:ga0aec29b4d4c9cf4412420b91c96ffe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6da9b0bf8e0287d71d02e2cd763cde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal__func__convolve2.htm#ga8a6da9b0bf8e0287d71d02e2cd763cde">convolve2NN</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;signal, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;<a class="el" href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">filter</a>, const <a class="el" href="classaf_1_1dim4.htm">dim4</a> stride, const <a class="el" href="classaf_1_1dim4.htm">dim4</a> padding, const <a class="el" href="classaf_1_1dim4.htm">dim4</a> dilation)</td></tr>
<tr class="memdesc:ga8a6da9b0bf8e0287d71d02e2cd763cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface for 2D convolution.  <a href="group__signal__func__convolve2.htm#ga8a6da9b0bf8e0287d71d02e2cd763cde">More...</a><br /></td></tr>
<tr class="separator:ga8a6da9b0bf8e0287d71d02e2cd763cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9144b146cb6c74da32eb75fdf3570b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal__func__convolve2.htm#ga9144b146cb6c74da32eb75fdf3570b27">fftConvolve2</a> (const <a class="el" href="classaf_1_1array.htm">array</a> &amp;signal, const <a class="el" href="classaf_1_1array.htm">array</a> &amp;<a class="el" href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">filter</a>, const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">convMode</a> mode=<a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga9144b146cb6c74da32eb75fdf3570b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Interface for convolution on 2D signals using FFT.  <a href="group__signal__func__convolve2.htm#ga9144b146cb6c74da32eb75fdf3570b27">More...</a><br /></td></tr>
<tr class="separator:ga9144b146cb6c74da32eb75fdf3570b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ab9a3d438ff793f530193b8ccb8003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal__func__convolve2.htm#gaa6ab9a3d438ff793f530193b8ccb8003">af_convolve2</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *out, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> signal, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> filter, const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">af_conv_mode</a> mode, <a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3db">af_conv_domain</a> domain)</td></tr>
<tr class="memdesc:gaa6ab9a3d438ff793f530193b8ccb8003"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface for convolution on two dimensional signals.  <a href="group__signal__func__convolve2.htm#gaa6ab9a3d438ff793f530193b8ccb8003">More...</a><br /></td></tr>
<tr class="separator:gaa6ab9a3d438ff793f530193b8ccb8003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06948be57cd0ec2e3646a7a57a5309b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal__func__convolve2.htm#ga06948be57cd0ec2e3646a7a57a5309b6">af_convolve2_nn</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *out, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> signal, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> filter, const unsigned stride_dims, const <a class="el" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> *strides, const unsigned padding_dims, const <a class="el" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> *paddings, const unsigned dilation_dims, const <a class="el" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> *dilations)</td></tr>
<tr class="memdesc:ga06948be57cd0ec2e3646a7a57a5309b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface for 2D convolution.  <a href="group__signal__func__convolve2.htm#ga06948be57cd0ec2e3646a7a57a5309b6">More...</a><br /></td></tr>
<tr class="separator:ga06948be57cd0ec2e3646a7a57a5309b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52ebe631d8358cdef1b5c8a95550556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal__func__convolve2.htm#gab52ebe631d8358cdef1b5c8a95550556">af_fft_convolve2</a> (<a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *out, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> signal, const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> filter, const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">af_conv_mode</a> mode)</td></tr>
<tr class="memdesc:gab52ebe631d8358cdef1b5c8a95550556"><td class="mdescLeft">&#160;</td><td class="mdescRight">C Interface for convolution on 2D signals using FFT.  <a href="group__signal__func__convolve2.htm#gab52ebe631d8358cdef1b5c8a95550556">More...</a><br /></td></tr>
<tr class="separator:gab52ebe631d8358cdef1b5c8a95550556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Convolution Integral for two dimensional data. </p>
<p>A convolution is a common operation between a source array, a, and a filter (or kernel) array b. The answer to the convolution is the same as computing the coefficients in polynomial multiplication, if a and b are the coefficients.</p>
<p>Another way to think about it is that the filter kernel is centered on each pixel in a, and the output for that pixel or data point is the sum of the products.</p>
<p>Depending on the size of the signal and the filter, any one of the following batch mode convolutions take place.</p>
<ul>
<li><b>No Batch</b> - Single filter applied to single input.</li>
<li><b>Filter is Batched</b> - Many filters applied on same input</li>
<li><b>Signal is Batched</b> - Single filter applied to a set of inputs.</li>
<li><b>Identical Batches</b> - A set of filters applied onto to a set of inputs in one-to-one correspondence.</li>
<li><b>Non overlapping Batches</b> - All batched filters are applied to all batched signals. The batch axis of Signal and Filter <b>should not</b> be the same.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All non-overlapping(interleaved) convolutions default to frequency domain <a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3dba0a1b168b058f58bd6b092af8bd5581fd">AF_CONV_FREQ</a> irrespective of the provided convolution mode argument.</dd></dl>
<p>A detailed explanation of each batch mode for 2D convolutions is provided below. Given below are definitions of variables and constants that are used to facilitate easy illustration of the operations.</p>
<ul>
<li>\([M\quad N]\), \([A\quad B]\) are signal, filter sizes along \(0^{th}\) &amp; \(1^{st}\) axes respectively.</li>
<li>\(P\) and \(Q\) are two constants, integers greater than one.</li>
<li>\( p \) is an integer variable with range \( \ 0 \leq p &lt; P \).</li>
<li>\( q \) is an integer variable with range \( \ 0 \leq q &lt; Q \).</li>
<li>O, S and F are notations for Output, Signal and Filter respectively.</li>
</ul>
<p>We have also used images to showcase some examples which follow the below notation.</p>
<ul>
<li>Each blue line is a two dimensional matrix.</li>
<li>Each orange line indicates a full 2d convolution operation.</li>
<li>Suffix of each letter indicates indices along \( 3^{rd}\) and \( 4^{th}\) axes in the order of appearance from left to right in the suffix.</li>
<li>O, S and F are notations for Output, Signal and Filter respectively.</li>
</ul>
<h3>No Batch</h3>
<p>Given below is an example of no batch mode.</p>
<div class="image">
<img src="basic.png" alt=""/>
<div class="caption">
Single 2d convolution with 2d filter</div></div>
<p>For input size \( [M \ N \ 1 \ 1] \) and filter size \( [A \ B \ 1 \ 1] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ 1 \ 1]}{O} \) = \( \underset{[M \ N \ 1 \ 1]}{S} \ast \underset{[A \ B \ 1 \ 1]}{F} \)</p>
<h3>Batched Filter</h3>
<p>Given below is an example of filter batch mode.</p>
<div class="image">
<img src="filter.png" alt=""/>
<div class="caption">
Single signal convolved with many filters independently</div></div>
<p>For input size \( [M \ N \ 1 \ 1] \) and filter size \( [A \ B \ P \ 1] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ P \ 1]}{O} \) = \( \left\{ \underset{[M \ N \ 1 \ 1]}{S} \ast \underset{[A \ B \ p \ 1]}{f} \ \Bigg\vert \ \forall \underset{[A \ B \ p \ 1]}{f} \in \underset{[A \ B \ P \ 1]}{F} \right\} \)</p>
<h3>Batched Signal</h3>
<p>Given below is an example of signal batch mode.</p>
<div class="image">
<img src="signal.png" alt=""/>
<div class="caption">
Single filter convolved with many signals independently</div></div>
<p>For input size \( [M \ N \ P \ 1] \) and filter size \( [A \ B \ 1 \ 1] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ P \ 1]}{O} \) = \( \left\{ \underset{[M \ N \ p \ 1]}{s} \ast \underset{[A \ B \ 1 \ 1]}{F} \ \Bigg\vert \ \forall \underset{[M \ N \ p \ 1]}{s} \in \underset{[M \ N \ P \ 1]}{S} \right\} \)</p>
<h3>Identical Batch Sizes</h3>
<p>Given below is an example of identical batch mode.</p>
<div class="image">
<img src="identical.png" alt=""/>
<div class="caption">
Many signals convolved with many filters in one-on-one manner</div></div>
<p>For input size \( [M \ N \ P \ Q] \) and filter size \( [A \ B \ P \ Q] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ P \ Q]}{O} \) = \( \left\{ \underset{[M \ N \ p \ q]}{s} \ast \underset{[A \ B \ p \ q]}{f} \ \Bigg\vert \ \forall \underset{[M \ N \ p \ q]}{s} \in \underset{[M \ N \ P \ Q]}{S} \land \forall \underset{[M \ N \ p \ q]}{f} \in \underset{[M \ N \ P \ Q]}{F} \right\} \)</p>
<h3>Non-overlapping Batches</h3>
<p>Four different kinds of signal and filter size combinations are handled in this batch mode. Each one of them are explained in respective sections below.</p>
<h4>Combination 1</h4>
<p>For input size \( [M \ N \ P \ 1] \) and filter size \( [A \ B \ 1 \ Q] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ P \ Q]}{O} \) = \( \left\{ \left\{ \underset{[M \ N \ p \ 1]}{s} \ast \underset{[A \ B \ 1 \ q]}{f} \ \Bigg\vert \ \forall \underset{[M \ N \ p \ 1]}{s} \in \underset{[M \ N \ P \ 1]}{S} \right\} \ \Bigg\vert \ \forall \underset{[A \ B \ 1 \ q]}{f} \in \underset{[A \ B \ 1 \ Q]}{F} \right\} \)</p>
<p>Given below is an example of this batch mode.</p>
<div class="image">
<img src="non-overlapping_1.png" alt=""/>
</div>
<h4>Combination 2</h4>
<p>For input size \( [M \ N \ P \ 1] \) and filter size \( [A \ B \ P \ Q] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ P \ Q]}{O} \) = \( \left\{ \left\{ \underset{[M \ N \ p \ 1]}{s} \ast \underset{[A \ B \ p \ q]}{f} \ \Bigg\vert \ \forall \underset{[A \ B \ p \ q]}{f} \in \underset{[A \ B \ P \ Q]}{F} \right\} \ \Bigg\vert \ \forall \underset{[M \ N \ p \ 1]}{s} \in \underset{[M \ N \ P \ 1]}{S} \right\} \)</p>
<p>Given below is an example of this batch mode.</p>
<div class="image">
<img src="non-overlapping_2.png" alt=""/>
</div>
<h4>Combination 3</h4>
<p>For input size \( [M \ N \ 1 \ P] \) and filter size \( [A \ B \ Q \ 1] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ Q \ P]}{O} \) = \( \left\{ \left\{ \underset{[M \ N \ 1 \ p]}{s} \ast \underset{[A \ B \ q \ 1]}{f} \ \Bigg\vert \ \forall \underset{[M \ N \ 1 \ p]}{s} \in \underset{[M \ N \ 1 \ P]}{S} \right\} \ \Bigg\vert \ \forall \underset{[A \ B \ q \ 1]}{f} \in \underset{[A \ B \ Q \ 1]}{F} \right\} \)</p>
<p>Given below is an example of this batch mode.</p>
<div class="image">
<img src="non-overlapping_3.png" alt=""/>
</div>
<h4>Combination 4</h4>
<p>For input size \( [M \ N \ P \ Q] \) and filter size \( [A \ B \ P \ 1] \), the following set-builder notation gives a formal definition of all convolutions performed in this mode.</p>
<p>\( \underset{[M \ N \ P \ Q]}{O} \) = \( \left\{ \left\{ \underset{[M \ N \ p \ q]}{s} \ast \underset{[A \ B \ p \ 1]}{f} \ \Bigg\vert \ \forall \underset{[M \ N \ p \ q]}{s} \in \underset{[M \ N \ P \ Q]}{S} \right\} \ \Bigg\vert \ \forall \underset{[A \ B \ p \ 1]}{f} \in \underset{[A \ B \ P \ 1]}{F} \right\} \)</p>
<p>Given below is an example of this batch mode.</p>
<div class="image">
<img src="non-overlapping_4.png" alt=""/>
</div>
<p>The batching behavior of convolve2NN functions(<a class="el" href="group__signal__func__convolve2.htm#ga06948be57cd0ec2e3646a7a57a5309b6">af_convolve2_nn()</a> and <a class="el" href="group__signal__func__convolve2.htm#ga8a6da9b0bf8e0287d71d02e2cd763cde">convolve2NN()</a> ) is different from convolve2. The new functions can perform 2D convolution on 3D signals and filters in a way that is more aligned with convolutional neural networks.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Signal Size </th><th class="markdownTableHeadCenter">Filter Size </th><th class="markdownTableHeadCenter">Output Size </th><th class="markdownTableHeadCenter">Batch Mode </th><th class="markdownTableHeadLeft">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( [M \ N \ 1 \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ 1 \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ 1 \ 1] \) </td><td class="markdownTableBodyCenter">No Batch </td><td class="markdownTableBodyLeft">Output will be a single convolved array  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( [M \ N \ 1 \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ P \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ P \ 1] \) </td><td class="markdownTableBodyCenter"><em>Invalid</em> </td><td class="markdownTableBodyLeft">Size along second axis should be same  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( [M \ N \ P \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ 1 \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ P \ 1] \) </td><td class="markdownTableBodyCenter"><em>Invalid</em> </td><td class="markdownTableBodyLeft">Size along second axis should be same  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">\( [M \ N \ P \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ P \ 1] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ 1 \ 1] \) </td><td class="markdownTableBodyCenter">No Batch </td><td class="markdownTableBodyLeft">3D Signal and 3D filter convoled to 2D result  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">\( [M \ N \ P \ Qs] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ P \ Qf] \) </td><td class="markdownTableBodyCenter">\( [M \ N \ Qf \ Qs] \) </td><td class="markdownTableBodyCenter">Batch Qs * Qf </td><td class="markdownTableBodyLeft">Qs signals and Qf filters to create Qs * Qf results  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>For the above tabular illustrations, we will assume <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">af_conv_mode</a> is <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a>. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa6ab9a3d438ff793f530193b8ccb8003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6ab9a3d438ff793f530193b8ccb8003">&#9670;&nbsp;</a></span>af_convolve2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_convolve2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">af_conv_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3db">af_conv_domain</a>&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface for convolution on two dimensional signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>is convolved array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is the input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>is the signal that shall be flipped for the convolution operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>indicates if the convolution should be expanded or not(where output size equals input) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>specifies if the convolution should be performed in frequency os spatial domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4fa2e56d1f9585788fed8fbe3a321bddd76">AF_SUCCESS</a> if the convolution is successful, otherwise an appropriate error code is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default parameter of <code>domain</code>, <a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3dbae105d11695ba3a2287e32c552d3567dd">AF_CONV_AUTO</a>, heuristically switches between frequency and spatial domain. </dd></dl>

</div>
</div>
<a id="ga06948be57cd0ec2e3646a7a57a5309b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06948be57cd0ec2e3646a7a57a5309b6">&#9670;&nbsp;</a></span>af_convolve2_nn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_convolve2_nn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>stride_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> *&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>padding_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> *&#160;</td>
          <td class="paramname"><em>paddings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>dilation_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a7f026aa801b1fa6b85b0d992b414cccb">dim_t</a> *&#160;</td>
          <td class="paramname"><em>dilations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface for 2D convolution. </p>
<p>This version of convolution is consistent with the machine learning formulation that will spatially convolve a filter on 2-dimensions against a signal. Multiple signals and filters can be batched against each other. Furthermore, the signals and filters can be multi-dimensional however their dimensions must match.</p>
<p>Example: Signals with dimensions: d0 x d1 x d2 x Ns Filters with dimensions: d0 x d1 x d2 x Nf</p>
<p>Resulting Convolution: d0 x d1 x Nf x Ns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>is convolved array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is the input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>is the filter that will be used for the convolution operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride_dims</td><td>specifies the number of stride dimension parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strides</td><td>array of values specifying the amounts the filter strides along each dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding_dims</td><td>specifies the number of padding dimension parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paddings</td><td>array of values specifying the amounts to pad along each dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dilation_dims</td><td>specifies the number of dilation dimension parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dilations</td><td>array of values specifying the amounts to dilate the filter before convolving along each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4fa2e56d1f9585788fed8fbe3a321bddd76">AF_SUCCESS</a> if the convolution is successful, otherwise an appropriate error code is returned. </dd></dl>

</div>
</div>
<a id="gab52ebe631d8358cdef1b5c8a95550556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52ebe631d8358cdef1b5c8a95550556">&#9670;&nbsp;</a></span>af_fft_convolve2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4f">af_err</a> af_fft_convolve2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8e45f4aa3dbea6a7aa021dbc50a4a089">af_array</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">af_conv_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C Interface for convolution on 2D signals using FFT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>is convolved array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is the input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>is the signal that shall be used for the convolution operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>indicates if the convolution should be expanded or not(where output size equals input) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="defines_8h.htm#a82b94dc53bbd100a0e8ca9dd356aaf4fa2e56d1f9585788fed8fbe3a321bddd76">AF_SUCCESS</a> if the convolution is successful, otherwise an appropriate error code is returned. </dd></dl>

</div>
</div>
<a id="ga0aec29b4d4c9cf4412420b91c96ffe6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aec29b4d4c9cf4412420b91c96ffe6c">&#9670;&nbsp;</a></span>convolve2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::convolve2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">convMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3db">convDomain</a>&#160;</td>
          <td class="paramname"><em>domain</em> = <code><a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3dbae105d11695ba3a2287e32c552d3567dd">AF_CONV_AUTO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface for convolution on two dimensional signals. </p>
<div class="fragment"><div class="line">    <span class="comment">// vector&lt;dim4&gt; numDims;</span></div>
<div class="line">    <span class="comment">// vector&lt;vector&lt;float&gt; &gt; in;</span></div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> signal(numDims[0], &amp;(in[0].front()));</div>
<div class="line">    <span class="comment">// signal dims = [15 17 1 1]</span></div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> <a class="code" href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">filter</a>(numDims[1], &amp;(in[1].front()));</div>
<div class="line">    <span class="comment">// filter dims = [5 5 2 1]</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">array</a> output = <a class="code" href="group__signal__func__convolve2.htm#ga0aec29b4d4c9cf4412420b91c96ffe6c">convolve2</a>(signal, <a class="code" href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">filter</a>, <a class="code" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a>);</div>
<div class="line">    <span class="comment">// output dims = [15 17 1 1] - same as input since expand(3rd argument is</span></div>
<div class="line">    <span class="comment">// false) however, notice that the 3rd dimension of filter is &gt; 1. So, one</span></div>
<div class="line">    <span class="comment">// to many batch mode will be activated automatically where the 2d input</span></div>
<div class="line">    <span class="comment">// signal is convolved with each 2d filter and the result will written</span></div>
<div class="line">    <span class="comment">// corresponding slice in the output 3d array</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is the input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>is the signal that shall be flipped for the convolution operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>indicates if the convolution should be expanded or not(where output size equals input) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>specifies if the convolution should be performed in frequency os spatial domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convolved array</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default parameter of <code>domain</code>, <a class="el" href="defines_8h.htm#a8519ae1caafab760d2421cd6ac13a3dbae105d11695ba3a2287e32c552d3567dd">AF_CONV_AUTO</a>, heuristically switches between frequency and spatial domain. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="getting_started_2convolve_8cpp-example.htm#a1">getting_started/convolve.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga8a6da9b0bf8e0287d71d02e2cd763cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a6da9b0bf8e0287d71d02e2cd763cde">&#9670;&nbsp;</a></span>convolve2NN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::convolve2NN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1dim4.htm">dim4</a>&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1dim4.htm">dim4</a>&#160;</td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1dim4.htm">dim4</a>&#160;</td>
          <td class="paramname"><em>dilation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface for 2D convolution. </p>
<p>This version of convolution is consistent with the machine learning formulation that will spatially convolve a filter on 2-dimensions against a signal. Multiple signals and filters can be batched against each other. Furthermore, the signals and filters can be multi-dimensional however their dimensions must match.</p>
<p>Example: Signals with dimensions: d0 x d1 x d2 x Ns Filters with dimensions: d0 x d1 x d2 x Nf</p>
<p>Resulting Convolution: d0 x d1 x Nf x Ns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is the input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>is the filter that will be used for the convolution operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>specifies the filter strides along each dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>specifies the padding along each dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dilation</td><td>specifies the amount to dilate the filter before convolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convolved array </dd></dl>

</div>
</div>
<a id="ga9144b146cb6c74da32eb75fdf3570b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9144b146cb6c74da32eb75fdf3570b27">&#9670;&nbsp;</a></span>fftConvolve2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defines_8h.htm#ab23e67549eba2cfbaf0eb5f88f947e48">AFAPI</a> <a class="el" href="classaf_1_1array.htm">array</a> af::fftConvolve2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaf_1_1array.htm">array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdc">convMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Interface for convolution on 2D signals using FFT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>is the input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>is the signal that shall be used for the convolution operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>indicates if the convolution should be expanded or not(where output size equals input) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convolved array </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="adefines_8h_htm_ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48"><div class="ttname"><a href="defines_8h.htm#ac999a96d4a0b4ff19efba40dd5894fdca35a0029690106be18b67f0f30357ab48">AF_CONV_DEFAULT</a></div><div class="ttdeci">@ AF_CONV_DEFAULT</div><div class="ttdoc">Output of the convolution is the same size as input.</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.htm#l00305">defines.h:305</a></div></div>
<div class="ttc" id="agroup__signal__func__convolve2_htm_ga0aec29b4d4c9cf4412420b91c96ffe6c"><div class="ttname"><a href="group__signal__func__convolve2.htm#ga0aec29b4d4c9cf4412420b91c96ffe6c">af::convolve2</a></div><div class="ttdeci">AFAPI array convolve2(const array &amp;signal, const array &amp;filter, const convMode mode=AF_CONV_DEFAULT, const convDomain domain=AF_CONV_AUTO)</div><div class="ttdoc">C++ Interface for convolution on two dimensional signals.</div></div>
<div class="ttc" id="agroup__opencl__mat_htm_ga5434aaf76be37fae92ac5086315516f0"><div class="ttname"><a href="group__opencl__mat.htm#ga5434aaf76be37fae92ac5086315516f0">afcl::array</a></div><div class="ttdeci">static af::array array(af::dim4 idims, cl_mem buf, af::dtype type, bool retain=false)</div><div class="ttdoc">Create an af::array object from an OpenCL cl_mem buffer.</div><div class="ttdef"><b>Definition:</b> <a href="opencl_8h_source.htm#l00327">opencl.h:327</a></div></div>
<div class="ttc" id="anamespaceaf_htm_a53c4f9a4b5440458bffe355803514c90"><div class="ttname"><a href="namespaceaf.htm#a53c4f9a4b5440458bffe355803514c90">af::filter</a></div><div class="ttdeci">AFAPI array filter(const array &amp;image, const array &amp;kernel)</div><div class="ttdoc">Image Filtering.</div></div>
</div>
</div>
</div>
</div>
</div>
<!--Google Analytics-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-130950618-1']);
  _gaq.push(['_setDomainName', '.arrayfire.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!--Spectate-->
<script type="text/javascript">
  sAId = "151";
  sCId = "688";
  (function() {
    function async_load(){
      var s = document.createElement('script'); s.type = 'text/javascript';
      s.src = (('https:' == document.location.protocol) ? "https://ssl" : "http://cdn") + ".spectate.com/s.js";
      var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
    }
    if(window.attachEvent) { window.attachEvent('onload', async_load); }
    else { window.addEventListener('load', async_load, false); }
  })();
</script>
<!--Adroll-->
<script type="text/javascript">
adroll_adv_id = "ZRWI4W4RTRHENOWGXZY5JQ";
adroll_pix_id = "QLXGBK3MSFB6LOL6PES2MT";
(function () {
var oldonload = window.onload;
window.onload = function(){
   __adroll_loaded=true;
   var scr = document.createElement("script");
   var host = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com");
   scr.setAttribute('async', 'true');
   scr.type = "text/javascript";
   scr.src = host + "/j/roundtrip.js";
   ((document.getElementsByTagName('head') || [null])[0] ||
    document.getElementsByTagName('script')[0].parentNode).appendChild(scr);
   if(oldonload){oldonload()}};
}());
</script>
</body>
</html>
